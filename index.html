<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PLAKKS-like Flick Soccer (Pseudo-3D)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2f;
      --panel2:#0b1427;
      --text:#eaf0ff;
      --muted:#a9b4d6;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --danger:#fb7185;
      --ok:#34d399;
      --shadow: rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; }

    /* ✅ altura real */
    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 800px at 30% 10%, #13214a 0%, #0b1220 55%, #060a14 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    .wrap{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:14px;
      max-width:1200px;
      margin:0 auto;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      backdrop-filter: blur(6px);
      flex:0 0 auto;
    }
    .leftHeader{ display:flex; flex-direction:column; gap:4px; }
    .title{
      font-weight:800;
      letter-spacing:.3px;
      font-size:16px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .badge{
      font-weight:700;
      font-size:12px;
      padding:3px 8px;
      border-radius:999px;
      background: rgba(125,211,252,.15);
      border:1px solid rgba(125,211,252,.35);
      color:#c9f2ff;
    }
    .sub{
      font-size:12px;
      color:var(--muted);
    }
    .hud{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .score{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.12));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      min-width: 190px;
      justify-content:space-between;
    }
    .teamTag{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:800;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      box-shadow: 0 0 0 3px rgba(255,255,255,.06), 0 10px 18px rgba(0,0,0,.25);
    }
    .dotA{ background: #ff6b6b; }
    .dotB{ background: #4da3ff; }
    .scoreNum{
      font-weight:900;
      font-size:20px;
      letter-spacing:.6px;
    }
    .turn{
      padding:8px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      font-weight:800;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    .turn .pill{
      width:10px; height:10px; border-radius:50%;
      box-shadow: 0 0 0 3px rgba(255,255,255,.07);
    }
    .btnRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      font-weight:800;
      font-size:12px;
      box-shadow: 0 10px 20px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.08);
      transition: transform .05s ease, border-color .15s ease, background .15s ease;
    }
    button:hover{ border-color: rgba(255,255,255,.18); }
    button:active{ transform: translateY(1px); }
    button.secondary{ background: linear-gradient(180deg, rgba(167,139,250,.16), rgba(167,139,250,.08)); border-color: rgba(167,139,250,.35); }
    button.danger{ background: linear-gradient(180deg, rgba(251,113,133,.18), rgba(251,113,133,.08)); border-color: rgba(251,113,133,.35); }
    button:disabled{ opacity:.55; cursor:not-allowed; transform:none; }

    .stage{
      position:relative;
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 260px;
    }

    .canvasShell{
      position:relative;
      flex:1 1 auto;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: 0 18px 42px rgba(0,0,0,.32);
      overflow:hidden;
      min-height: 520px;
    }

    /* ✅ Canvas “a prueba de balas”: rellena el contenedor y con fondo temporal */
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      background:#0a1020; /* temporal: confirma que se está pintando */
    }

    .overlayNote{
      position:absolute;
      left:12px; bottom:10px;
      font-size:12px;
      color:rgba(234,240,255,.75);
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:8px 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      max-width:min(420px, calc(100% - 24px));
      z-index:5;
    }
    .overlayNote b{ color:#ffffff; }

    .goalBanner{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      opacity:0;
      transition: opacity .2s ease;
      z-index:6;
    }
    .goalBanner.show{ opacity:1; }
    .goalText{
      font-weight:1000;
      letter-spacing: 2px;
      font-size: clamp(44px, 7vw, 92px);
      padding: 10px 22px;
      border-radius: 20px;
      background: radial-gradient(700px 120px at 50% 30%, rgba(255,255,255,.22), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 24px 80px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.15);
      text-shadow: 0 16px 30px rgba(0,0,0,.45);
      transform: translateY(10px) scale(.98);
      transition: transform .2s ease;
    }
    .goalBanner.show .goalText{ transform: translateY(0) scale(1); }

    .modalBack{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modalBack.show{ display:flex; }
    .modal{
      width:min(760px, 100%);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(15,26,47,.96), rgba(11,20,39,.94));
      box-shadow: 0 30px 100px rgba(0,0,0,.55);
      padding:16px 16px 12px;
      backdrop-filter: blur(8px);
    }
    .modal h2{ margin:0 0 8px; font-size:16px; }
    .modal p, .modal li{ color: rgba(234,240,255,.85); font-size:13px; line-height:1.45; }
    .modal ul{ margin:8px 0 0 18px; }
    .modal .top{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      margin-bottom: 10px;
    }
    .modal .x{
      border-radius:12px;
      padding:9px 12px;
    }

    @media (max-width: 720px){
      header{ flex-direction:column; align-items:stretch; }
      .hud{ justify-content:space-between; }
      .score{ min-width: unset; flex:1; }
      .btnRow{ justify-content:space-between; }
      button{ flex:1; }
      .canvasShell{ min-height: 62vh; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="leftHeader">
      <div class="title">
        PLAKKS-like Flick Soccer <span class="badge">pseudo-3D</span>
      </div>
      <div class="sub">Turnos alternos · Flick con un palito · Goles = palitos retirados al rival</div>
    </div>

    <div class="hud">
      <div class="score" aria-label="Marcador">
        <div class="teamTag"><span class="dot dotA"></span>Equipo A</div>
        <div class="scoreNum"><span id="scoreA">0</span> – <span id="scoreB">0</span></div>
        <div class="teamTag">Equipo B<span class="dot dotB"></span></div>
      </div>

      <div class="turn" aria-label="Turno actual">
        <span>Turno:</span>
        <span class="pill" id="turnPill"></span>
        <span id="turnText">Equipo A</span>
      </div>

      <div class="btnRow">
        <button id="btnUndo" class="secondary" title="Deshacer el último tiro">Deshacer último tiro</button>
        <button id="btnReset" class="danger" title="Reiniciar el partido">Reiniciar partido</button>
        <button id="btnHelp" title="Ver ayuda y controles">Ayuda</button>
      </div>
    </div>
  </header>

  <div class="stage">
    <div class="canvasShell">
      <canvas id="game"></canvas>

      <div class="goalBanner" id="goalBanner">
        <div class="goalText">GOOOL</div>
      </div>

      <div class="overlayNote" id="note">
        <b>Cómo tirar:</b> Click en tu palito → arrastra para apuntar → suelta para chutar. <br/>
        <span style="opacity:.9">Consejo:</span> Si no puedes seleccionar, espera a que el juego termine de simular el tiro anterior.
      </div>
    </div>
  </div>
</div>

<div class="modalBack" id="helpBack" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="modal">
    <div class="top">
      <h2 id="helpTitle">Ayuda · Reglas y controles</h2>
      <button class="x" id="btnCloseHelp">Cerrar</button>
    </div>
    <p><b>Objetivo:</b> marca goles metiendo la bola en la portería rival. Cada gol hace que el equipo que encaja retire 1 palito del campo. El marcador es “goles = palitos retirados al rival”. Gana quien llegue a 11.</p>
    <ul>
      <li><b>Turnos:</b> alternan Equipo A y Equipo B. En tu turno haces <b>un</b> flick con <b>uno</b> de tus palitos.</li>
      <li><b>Flick:</b> click en tu palito para seleccionarlo → arrastra para ajustar dirección y potencia → suelta para aplicar el impulso (tirachinas).</li>
      <li><b>Fin de turno:</b> el turno cambia cuando todo se ha casi detenido, hay gol o se alcanza un tiempo máximo de simulación.</li>
      <li><b>Deshacer:</b> revierte el estado completo al instante anterior al último flick (posiciones, velocidades, turno, marcador y palitos retirados).</li>
      <li><b>Sin faltas:</b> cualquier gol cuenta, incluso desde el reinicio.</li>
    </ul>
    <p style="margin-top:10px; color:rgba(234,240,255,.75)">
      Nota: el juego usa una física 2D estable (colisiones circulares, corrección de penetración, damping y rebotes) con estética pseudo-3D.
    </p>
  </div>
</div>

<!-- ✅ Overlay de errores en pantalla -->
<div id="err"
     style="position:fixed;left:12px;top:12px;max-width:min(900px,calc(100% - 24px));
            padding:10px 12px;border-radius:12px;z-index:9999;display:none;
            background:rgba(0,0,0,.75);border:1px solid rgba(255,255,255,.15);
            color:#ffe4e6;font:600 12px/1.35 ui-sans-serif,system-ui;">
</div>

<script>
/**
 * PLAKKS-like Flick Soccer (pseudo-3D)
 * Vanilla JS, single-file.
 */

/* =========================
   CONFIG (tweak here)
========================= */
const CONFIG = {
  world: { w: 1200, h: 720, wallThickness: 30 },
  goal: { opening: 220, depth: 42, postRadius: 10, netAlpha: 0.25 },
  ball: { r: 16, mass: 1.0, restitution: 0.92, linearDamp: 0.995, maxSpeed: 2400 },
  peg: { r: 24, mass: 3.0, restitution: 0.65, linearDamp: 0.992, maxSpeed: 2200 },
  teams: { count: 11 },
  flick: { maxDrag: 160, maxImpulse: 1800, minImpulse: 120, aimLineWidth: 3 },
  physics: {
    dt: 1/120, maxSubStepsPerFrame: 10, solverIterations: 4,
    wallRestitution: 0.86, stopSpeed: 16, sleepTimeMax: 4.0,
    penetrationSlop: 0.02, penetrationPercent: 0.9,
  },
  render: { vignette: true, shadowOffset: { x: 10, y: 14 }, shadowBlur: 16, pitchMargin: 28, grassNoise: 0.06, pitchCornerR: 38 },
  effects: { goalBannerMs: 850, goalPauseMs: 500, goalRippleMs: 520, goalFlashAlpha: 0.25 },
  sound: { enabled: true, goalVolume: 0.12 }
};

const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const len = (x, y) => Math.hypot(x, y);
const lerp = (a, b, t) => a + (b - a) * t;
const nowMs = () => performance.now();
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

class Vec2{
  constructor(x=0,y=0){ this.x=x; this.y=y; }
  clone(){ return new Vec2(this.x,this.y); }
  add(v){ this.x+=v.x; this.y+=v.y; return this; }
  sub(v){ this.x-=v.x; this.y-=v.y; return this; }
  mul(s){ this.x*=s; this.y*=s; return this; }
  dot(v){ return this.x*v.x + this.y*v.y; }
  mag(){ return Math.hypot(this.x,this.y); }
  norm(){ const m=this.mag(); if(m>1e-8){ this.x/=m; this.y/=m; } return this; }
  static sub(a,b){ return new Vec2(a.x-b.x, a.y-b.y); }
  static mul(a,s){ return new Vec2(a.x*s, a.y*s); }
}

class Body{
  constructor(x,y,r,mass){
    this.p=new Vec2(x,y); this.v=new Vec2(0,0);
    this.r=r; this.mass=mass; this.invMass=mass>0?1/mass:0;
    this.restitution=0.8; this.damp=0.995; this.maxSpeed=2000;
    this.active=true;
  }
  speed(){ return this.v.mag(); }
}
class Ball extends Body{
  constructor(x,y){ super(x,y,CONFIG.ball.r,CONFIG.ball.mass);
    this.restitution=CONFIG.ball.restitution; this.damp=CONFIG.ball.linearDamp; this.maxSpeed=CONFIG.ball.maxSpeed;
  }
}
class Peg extends Body{
  constructor(x,y,team,id){ super(x,y,CONFIG.peg.r,CONFIG.peg.mass);
    this.team=team; this.id=id;
    this.restitution=CONFIG.peg.restitution; this.damp=CONFIG.peg.linearDamp; this.maxSpeed=CONFIG.peg.maxSpeed;
    this.spinHint=(Math.random()*2-1)*0.35;
  }
}

class Physics{
  constructor(game){ this.game=game; }
  step(dt){
    const {world}=CONFIG;
    const bodies=this.game.getActiveBodies();

    for(const b of bodies){
      b.p.x += b.v.x*dt; b.p.y += b.v.y*dt;
      b.v.mul(b.damp);
      const s=b.speed();
      if(s>b.maxSpeed) b.v.mul(b.maxSpeed/(s+1e-9));
      this.resolveWalls(b, world.w, world.h);
    }

    for(let it=0; it<CONFIG.physics.solverIterations; it++){
      for(let i=0;i<bodies.length;i++){
        for(let j=i+1;j<bodies.length;j++){
          this.resolveCircleCollision(bodies[i], bodies[j]);
        }
      }
    }
  }
  resolveWalls(b,W,H){
    const e=CONFIG.physics.wallRestitution;
    if(b.p.x-b.r<0){ b.p.x=b.r; b.v.x=Math.abs(b.v.x)*e; }
    if(b.p.x+b.r>W){ b.p.x=W-b.r; b.v.x=-Math.abs(b.v.x)*e; }
    if(b.p.y-b.r<0){ b.p.y=b.r; b.v.y=Math.abs(b.v.y)*e; }
    if(b.p.y+b.r>H){ b.p.y=H-b.r; b.v.y=-Math.abs(b.v.y)*e; }
  }
  resolveCircleCollision(a,b){
    if(!a.active||!b.active) return;
    const n=Vec2.sub(b.p,a.p);
    let dist=n.mag();
    const r=a.r+b.r;
    if(dist<=0) dist=0.0001;

    if(dist<r){
      const penetration=r-dist;
      const normal=n.mul(1/dist);
      const invMassSum=a.invMass+b.invMass;
      if(invMassSum<=0) return;

      const slop=CONFIG.physics.penetrationSlop;
      const percent=CONFIG.physics.penetrationPercent;
      const correctionMag=Math.max(penetration-slop,0)/invMassSum*percent;

      a.p.x -= normal.x*correctionMag*a.invMass;
      a.p.y -= normal.y*correctionMag*a.invMass;
      b.p.x += normal.x*correctionMag*b.invMass;
      b.p.y += normal.y*correctionMag*b.invMass;

      const rv=new Vec2(b.v.x-a.v.x, b.v.y-a.v.y);
      const velAlongNormal=rv.dot(normal);

      if(velAlongNormal<0){
        const e=Math.min(a.restitution,b.restitution);
        let j=-(1+e)*velAlongNormal;
        j/=invMassSum;
        const impulse=Vec2.mul(normal,j);

        a.v.x -= impulse.x*a.invMass; a.v.y -= impulse.y*a.invMass;
        b.v.x += impulse.x*b.invMass; b.v.y += impulse.y*b.invMass;

        const tangent=new Vec2(rv.x-velAlongNormal*normal.x, rv.y-velAlongNormal*normal.y);
        const tmag=tangent.mag();
        if(tmag>1e-6){
          tangent.mul(1/tmag);
          const jt=-rv.dot(tangent)*0.03;
          const tImpulse=Vec2.mul(tangent,jt);
          a.v.x -= tImpulse.x*a.invMass; a.v.y -= tImpulse.y*a.invMass;
          b.v.x += tImpulse.x*b.invMass; b.v.y += tImpulse.y*b.invMass;
        }
      }
    }
  }
}

class Renderer{
  constructor(game,canvas){
    this.game=game; this.canvas=canvas; this.ctx=canvas.getContext('2d');
    this.noiseCanvas=document.createElement('canvas');
    this.noiseCanvas.width=256; this.noiseCanvas.height=256;
    this.noiseCtx=this.noiseCanvas.getContext('2d');
    this.buildNoise();
    this._lastW=0; this._lastH=0;
    this.scale=1; this.offset=new Vec2(0,0);
  }

  buildNoise(){
    const ctx=this.noiseCtx;
    const img=ctx.createImageData(256,256);
    for(let i=0;i<img.data.length;i+=4){
      const n=(Math.random()*2-1)*255;
      img.data[i]=0;
      img.data[i+1]=120+n*0.08;
      img.data[i+2]=0;
      img.data[i+3]=255;
    }
    ctx.putImageData(img,0,0);
  }

  /* ✅ resize “a prueba de balas”: fallback al padre y a tamaño fijo */
  resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    let rect = this.canvas.getBoundingClientRect();

    if(rect.width < 2 || rect.height < 2){
      const parent = this.canvas.parentElement;
      if(parent) rect = parent.getBoundingClientRect();
    }

    const cssW = Math.max(300, rect.width || 900);
    const cssH = Math.max(300, rect.height || 540);

    const w = Math.floor(cssW * dpr);
    const h = Math.floor(cssH * dpr);

    if(w === this._lastW && h === this._lastH) return;

    this._lastW = w; this._lastH = h;
    this.canvas.width = w;
    this.canvas.height = h;

    const pad = CONFIG.render.pitchMargin * dpr;
    const sx = (w - pad*2) / CONFIG.world.w;
    const sy = (h - pad*2) / CONFIG.world.h;
    this.scale = Math.min(sx, sy);

    if(!isFinite(this.scale) || this.scale <= 0) this.scale = 0.5;

    this.offset = new Vec2(
      (w - CONFIG.world.w * this.scale) * 0.5,
      (h - CONFIG.world.h * this.scale) * 0.5
    );
  }

  worldToScreen(v){ return new Vec2(this.offset.x+v.x*this.scale, this.offset.y+v.y*this.scale); }
  screenToWorld(v){ return new Vec2((v.x-this.offset.x)/this.scale, (v.y-this.offset.y)/this.scale); }

  draw(){
    this.resize();
    const ctx=this.ctx;
    const w=this.canvas.width, h=this.canvas.height;
    ctx.clearRect(0,0,w,h);
    this.drawPitch(ctx);
    this.drawGoals(ctx);
    this.drawBodies(ctx);
    this.drawAim(ctx);
    this.drawGoalRipple(ctx);
    this.drawVignette(ctx);
  }

  drawPitch(ctx){
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const W=CONFIG.world.w, H=CONFIG.world.h;
    const s=this.scale;
    const ox=this.offset.x, oy=this.offset.y;
    const x0=ox, y0=oy, x1=ox+W*s, y1=oy+H*s;

    const g=ctx.createLinearGradient(x0,y0,x1,y1);
    g.addColorStop(0,'#0f6b3c');
    g.addColorStop(0.5,'#0e5f37');
    g.addColorStop(1,'#0b4a2c');

    const r=CONFIG.render.pitchCornerR*dpr;
    ctx.save();
    ctx.fillStyle=g;
    this.roundRect(ctx,x0,y0,W*s,H*s,r);
    ctx.fill();

    ctx.globalAlpha=0.13;
    const stripeCount=10;
    for(let i=0;i<stripeCount;i++){
      const yy=y0+(H*s)*(i/stripeCount);
      ctx.fillStyle=(i%2===0)?'#0b4f2f':'#0f7343';
      ctx.fillRect(x0,yy,W*s,(H*s)/stripeCount);
    }
    ctx.globalAlpha=1;

    ctx.globalAlpha=CONFIG.render.grassNoise;
    ctx.drawImage(this.noiseCanvas,x0,y0,W*s,H*s);
    ctx.globalAlpha=1;

    const lineW=3*dpr;
    ctx.lineWidth=lineW;
    ctx.strokeStyle='rgba(245,255,245,.82)';
    ctx.shadowColor='rgba(0,0,0,.18)';
    ctx.shadowBlur=6*dpr;
    ctx.shadowOffsetX=1*dpr;
    ctx.shadowOffsetY=2*dpr;

    this.roundRect(ctx,x0+lineW,y0+lineW,W*s-2*lineW,H*s-2*lineW,Math.max(2,r-6*dpr));
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x0+(W*s)/2, y0+lineW);
    ctx.lineTo(x0+(W*s)/2, y1-lineW);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(x0+(W*s)/2,y0+(H*s)/2,110*s,0,Math.PI*2);
    ctx.stroke();

    ctx.fillStyle='rgba(245,255,245,.9)';
    ctx.shadowBlur=0;
    ctx.beginPath();
    ctx.arc(x0+(W*s)/2,y0+(H*s)/2,5*dpr,0,Math.PI*2);
    ctx.fill();

    const open=CONFIG.goal.opening;
    const areaW=150, areaH=open+120;
    this.strokeRectCentered(ctx,75,H/2,areaW,areaH,s,x0,y0);
    this.strokeRectCentered(ctx,W-75,H/2,areaW,areaH,s,x0,y0);

    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation='destination-over';
    ctx.shadowColor='rgba(0,0,0,.55)';
    ctx.shadowBlur=30*dpr;
    ctx.shadowOffsetY=18*dpr;
    ctx.shadowOffsetX=0;
    ctx.fillStyle='rgba(0,0,0,.0)';
    this.roundRect(ctx,x0,y0,W*s,H*s,r);
    ctx.fill();
    ctx.restore();
  }

  strokeRectCentered(ctx,cx,cy,rw,rh,s,x0,y0){
    const x=x0+(cx-rw/2)*s;
    const y=y0+(cy-rh/2)*s;
    ctx.beginPath();
    ctx.rect(x,y,rw*s,rh*s);
    ctx.stroke();
  }

  drawGoals(ctx){
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const W=CONFIG.world.w, H=CONFIG.world.h;
    const s=this.scale, ox=this.offset.x, oy=this.offset.y;
    const open=CONFIG.goal.opening, depth=CONFIG.goal.depth, postR=CONFIG.goal.postRadius;
    this.drawOneGoal(ctx,'left',ox,oy,s,W,H,open,depth,postR,dpr);
    this.drawOneGoal(ctx,'right',ox,oy,s,W,H,open,depth,postR,dpr);
  }

  drawOneGoal(ctx,side,ox,oy,s,W,H,open,depth,postR,dpr){
    const cx=(side==='left')?0:W;
    const yTop=(H-open)/2;
    const yBot=yTop+open;
    const xEdge=ox+cx*s;
    const yT=oy+yTop*s;
    const yB=oy+yBot*s;
    const d=depth*s;
    const dir=(side==='left')?1:-1;

    ctx.save();
    ctx.lineWidth=2.5*dpr;
    ctx.strokeStyle='rgba(255,255,255,.35)';
    ctx.shadowColor='rgba(0,0,0,.25)';
    ctx.shadowBlur=10*dpr;
    ctx.shadowOffsetX=2*dpr;
    ctx.shadowOffsetY=3*dpr;

    ctx.beginPath();
    ctx.moveTo(xEdge+dir*d,yT+d*0.2);
    ctx.lineTo(xEdge+dir*d,yB-d*0.2);
    ctx.stroke();

    ctx.globalAlpha=CONFIG.goal.netAlpha;
    ctx.strokeStyle='rgba(255,255,255,.7)';
    ctx.shadowBlur=0;
    for(let i=0;i<10;i++){
      const t=i/9;
      const yy=lerp(yT+6*dpr,yB-6*dpr,t);
      ctx.beginPath();
      ctx.moveTo(xEdge,yy);
      ctx.lineTo(xEdge+dir*d,yy+d*0.12*(side==='left'?1:-1));
      ctx.stroke();
    }
    for(let i=0;i<8;i++){
      const t=i/7;
      const xx=lerp(xEdge,xEdge+dir*d,t);
      ctx.beginPath();
      ctx.moveTo(xx,yT);
      ctx.lineTo(xx+dir*d*0.08,yB);
      ctx.stroke();
    }

    ctx.globalAlpha=1;
    ctx.shadowBlur=16*dpr;
    ctx.shadowOffsetX=0;
    ctx.shadowOffsetY=10*dpr;
    ctx.shadowColor='rgba(0,0,0,.25)';

    const postX=xEdge+dir*(postR*s*0.15);
    const r=postR*s;
    this.drawPost(ctx,postX,yT,r,dpr);
    this.drawPost(ctx,postX,yB,r,dpr);

    ctx.shadowBlur=0;
    ctx.lineWidth=6*dpr;
    ctx.strokeStyle='rgba(255,255,255,.65)';
    ctx.beginPath();
    ctx.moveTo(postX,yT);
    ctx.lineTo(postX,yB);
    ctx.stroke();

    ctx.restore();
  }

  drawPost(ctx,x,y,r,dpr){
    const grd=ctx.createRadialGradient(x-r*0.4,y-r*0.4,r*0.3,x,y,r*1.05);
    grd.addColorStop(0,'rgba(255,255,255,.95)');
    grd.addColorStop(0.6,'rgba(255,255,255,.55)');
    grd.addColorStop(1,'rgba(255,255,255,.25)');
    ctx.fillStyle=grd;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.22)';
    ctx.lineWidth=1.2*dpr;
    ctx.stroke();
  }

  drawBodies(ctx){
    const bodies=this.game.getRenderBodiesSorted();
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    for(const b of bodies) this.drawShadow(ctx,b,dpr);
    for(const b of bodies){
      if(b instanceof Ball) this.drawBall(ctx,b,dpr);
      else this.drawPeg(ctx,b,dpr);
    }
  }

  drawShadow(ctx,b,dpr){
    const sp=this.worldToScreen(b.p);
    const r=b.r*this.scale;
    const off=CONFIG.render.shadowOffset;
    const sx=sp.x+off.x*dpr;
    const sy=sp.y+off.y*dpr;

    ctx.save();
    ctx.globalAlpha=0.38;
    ctx.fillStyle='rgba(0,0,0,.55)';
    ctx.shadowColor='rgba(0,0,0,.55)';
    ctx.shadowBlur=CONFIG.render.shadowBlur*dpr;
    ctx.beginPath();
    ctx.ellipse(sx,sy,r*1.05,r*0.78,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  drawBall(ctx,ball,dpr){
    const sp=this.worldToScreen(ball.p);
    const r=ball.r*this.scale;
    ctx.save();
    const g=ctx.createRadialGradient(sp.x-r*0.35,sp.y-r*0.35,r*0.35,sp.x,sp.y,r*1.15);
    g.addColorStop(0,'rgba(255,255,255,.98)');
    g.addColorStop(0.35,'rgba(255,255,255,.92)');
    g.addColorStop(0.7,'rgba(220,230,255,.88)');
    g.addColorStop(1,'rgba(140,160,190,.85)');
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(sp.x,sp.y,r,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.18)';
    ctx.lineWidth=1.3*dpr;
    ctx.stroke();
    ctx.globalAlpha=0.55;
    ctx.fillStyle='rgba(255,255,255,.85)';
    ctx.beginPath();
    ctx.ellipse(sp.x-r*0.25,sp.y-r*0.35,r*0.35,r*0.25,-0.6,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  drawPeg(ctx,peg,dpr){
    const sp=this.worldToScreen(peg.p);
    const r=peg.r*this.scale;
    const base=(peg.team==='A')?{a:'#ff6b6b',b:'#b81f3d'}:{a:'#4da3ff',b:'#124fae'};
    ctx.save();
    const g=ctx.createRadialGradient(sp.x-r*0.35,sp.y-r*0.25,r*0.2,sp.x,sp.y,r*1.15);
    g.addColorStop(0,'rgba(255,255,255,.55)');
    g.addColorStop(0.18,base.a);
    g.addColorStop(1,base.b);
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(sp.x,sp.y,r,0,Math.PI*2);
    ctx.fill();

    ctx.globalAlpha=0.10;
    ctx.strokeStyle='rgba(255,255,255,.7)';
    ctx.lineWidth=1*dpr;
    for(let i=0;i<3;i++){
      const ang=peg.spinHint+i*0.85;
      ctx.beginPath();
      ctx.arc(sp.x,sp.y,r*(0.55+i*0.12),ang,ang+Math.PI*1.6);
      ctx.stroke();
    }
    ctx.globalAlpha=1;

    ctx.strokeStyle='rgba(0,0,0,.22)';
    ctx.lineWidth=1.4*dpr;
    ctx.stroke();

    ctx.globalAlpha=0.55;
    const hg=ctx.createLinearGradient(sp.x-r*0.7,sp.y-r*0.2,sp.x+r*0.7,sp.y+r*0.2);
    hg.addColorStop(0,'rgba(255,255,255,.0)');
    hg.addColorStop(0.38,'rgba(255,255,255,.42)');
    hg.addColorStop(0.62,'rgba(255,255,255,.12)');
    hg.addColorStop(1,'rgba(255,255,255,.0)');
    ctx.fillStyle=hg;
    ctx.beginPath();
    ctx.ellipse(sp.x-r*0.1,sp.y-r*0.1,r*0.9,r*0.55,-0.55,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha=1;

    if(this.game.input.selectedPeg && this.game.input.selectedPeg.id===peg.id && this.game.input.selectedPeg.team===peg.team){
      ctx.strokeStyle='rgba(125,211,252,.95)';
      ctx.lineWidth=3*dpr;
      ctx.beginPath();
      ctx.arc(sp.x,sp.y,r+4*dpr,0,Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  drawAim(ctx){
    const input=this.game.input;
    if(!input.isAiming) return;
    const peg=input.selectedPegObj;
    if(!peg || !peg.active) return;

    const ctx=this.ctx;
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const p=this.worldToScreen(peg.p);
    const m=input.mouseScreen;

    const dx=m.x-p.x, dy=m.y-p.y;
    const dist=Math.hypot(dx,dy);
    const maxD=CONFIG.flick.maxDrag*dpr;
    const t=clamp(dist/maxD,0,1);

    ctx.save();
    ctx.lineWidth=CONFIG.flick.aimLineWidth*dpr;
    ctx.lineCap='round';
    ctx.strokeStyle=`rgba(125,211,252,${0.18+0.62*t})`;
    ctx.shadowColor='rgba(0,0,0,.35)';
    ctx.shadowBlur=10*dpr;

    ctx.beginPath();
    ctx.moveTo(p.x,p.y);
    ctx.lineTo(p.x+dx*clamp(maxD/(dist||1),0,1), p.y+dy*clamp(maxD/(dist||1),0,1));
    ctx.stroke();

    const end={ x:p.x+dx*clamp(maxD/(dist||1),0,1), y:p.y+dy*clamp(maxD/(dist||1),0,1) };
    const ang=Math.atan2(dy,dx);
    const ah=10*dpr;
    ctx.beginPath();
    ctx.moveTo(end.x,end.y);
    ctx.lineTo(end.x-Math.cos(ang-0.55)*ah, end.y-Math.sin(ang-0.55)*ah);
    ctx.lineTo(end.x-Math.cos(ang+0.55)*ah, end.y-Math.sin(ang+0.55)*ah);
    ctx.closePath();
    ctx.fillStyle=`rgba(125,211,252,${0.22+0.58*t})`;
    ctx.fill();

    const bw=170*dpr, bh=10*dpr;
    const bx=this.offset.x+14*dpr, by=this.offset.y+(CONFIG.world.h*this.scale)-20*dpr;
    ctx.shadowBlur=0;
    ctx.fillStyle='rgba(0,0,0,.25)';
    this.roundRect(ctx,bx,by,bw,bh,6*dpr); ctx.fill();

    const pw=bw*t;
    const pg=ctx.createLinearGradient(bx,by,bx+bw,by);
    pg.addColorStop(0,'rgba(52,211,153,.9)');
    pg.addColorStop(0.55,'rgba(125,211,252,.9)');
    pg.addColorStop(1,'rgba(251,113,133,.9)');
    ctx.fillStyle=pg;
    this.roundRect(ctx,bx,by,pw,bh,6*dpr); ctx.fill();

    ctx.restore();
  }

  drawGoalRipple(ctx){
    const eff=this.game.effects;
    if(!eff.goalRipple) return;
    const t=(nowMs()-eff.goalRipple.t0)/CONFIG.effects.goalRippleMs;
    if(t>=1){ eff.goalRipple=null; return; }

    const side=eff.goalRipple.side;
    const W=CONFIG.world.w, H=CONFIG.world.h;
    const x=(side==='left')?0:W;
    const y=H/2;
    const center=this.worldToScreen(new Vec2(x,y));
    const maxR=210*this.scale;
    const r=lerp(12*this.scale,maxR,t);

    ctx.save();
    ctx.globalAlpha=(1-t)*0.55;
    ctx.strokeStyle=(side==='left')?'rgba(255,107,107,.95)':'rgba(77,163,255,.95)';
    ctx.lineWidth=3*(Math.max(1, Math.min(2, window.devicePixelRatio||1)));
    ctx.beginPath();
    ctx.arc(center.x,center.y,r,-Math.PI/2,Math.PI/2);
    ctx.stroke();

    ctx.globalAlpha=(1-t)*CONFIG.effects.goalFlashAlpha;
    const dir=(side==='left')?1:-1;
    const mouthH=CONFIG.goal.opening*this.scale;
    ctx.fillStyle='white';
    ctx.fillRect(center.x+dir*2, center.y-mouthH/2, dir*40, mouthH);
    ctx.restore();
  }

  drawVignette(ctx){
    if(!CONFIG.render.vignette) return;
    const w=this.canvas.width, h=this.canvas.height;
    const g=ctx.createRadialGradient(w*0.5,h*0.5,Math.min(w,h)*0.25,w*0.5,h*0.5,Math.max(w,h)*0.65);
    g.addColorStop(0,'rgba(0,0,0,0)');
    g.addColorStop(1,'rgba(0,0,0,.35)');
    ctx.save();
    ctx.fillStyle=g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  roundRect(ctx,x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
}

class Input{
  constructor(game,canvas,renderer){
    this.game=game; this.canvas=canvas; this.renderer=renderer;
    this.mouseScreen=new Vec2(0,0);
    this.mouseWorld=new Vec2(0,0);
    this.selectedPeg=null;
    this.selectedPegObj=null;
    this.isDown=false;
    this.isAiming=false;
    this.downOnSelected=false;
    this.bind();
  }
  bind(){
    const onPointerDown=(e)=>{
      if(this.game.state.phase!=='ready') return;
      this.canvas.setPointerCapture?.(e.pointerId);
      const p=this.getPointerPos(e);
      this.mouseScreen=p;
      this.mouseWorld=this.renderer.screenToWorld(p);
      this.isDown=true;

      const peg=this.game.pickPegAt(this.mouseWorld,this.game.state.turn);
      if(peg){
        this.selectedPeg={ team: peg.team, id: peg.id };
        this.selectedPegObj=peg;
        this.downOnSelected=true;
        this.isAiming=true;
      } else {
        this.downOnSelected=false;
      }
    };

    const onPointerMove=(e)=>{
      const p=this.getPointerPos(e);
      this.mouseScreen=p;
      this.mouseWorld=this.renderer.screenToWorld(p);
    };

    const onPointerUp=(e)=>{
      if(!this.isDown) return;
      this.isDown=false;

      if(this.game.state.phase!=='ready'){
        this.isAiming=false; this.downOnSelected=false;
        return;
      }
      if(this.isAiming && this.downOnSelected && this.selectedPegObj && this.selectedPegObj.active){
        const peg=this.selectedPegObj;
        const sp=this.renderer.worldToScreen(peg.p);
        const p=this.mouseScreen;

        const dx=p.x-sp.x, dy=p.y-sp.y;
        const dist=Math.hypot(dx,dy);
        const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
        const maxD=CONFIG.flick.maxDrag*dpr;

        const clamped=Math.min(dist,maxD);
        const t=clamped/maxD;

        if(clamped>2*dpr){
          const dir=new Vec2(-dx,-dy).mul(1/(dist||1));
          const impulse=lerp(CONFIG.flick.minImpulse, CONFIG.flick.maxImpulse, t);
          this.game.tryFlick(peg,dir,impulse);
        }
      }
      this.isAiming=false;
      this.downOnSelected=false;
    };

    this.canvas.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove, { passive:true });
    window.addEventListener('pointerup', onPointerUp);

    this.canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
    this.canvas.addEventListener('touchmove', (e)=>e.preventDefault(), {passive:false});
  }

  getPointerPos(e){
    const rect=this.canvas.getBoundingClientRect();
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    return new Vec2((e.clientX-rect.left)*dpr, (e.clientY-rect.top)*dpr);
  }
}

class Sound{
  constructor(){ this.ctx=null; }
  ensure(){
    if(!CONFIG.sound.enabled) return null;
    if(this.ctx) return this.ctx;
    try{ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); return this.ctx; }
    catch(_){ return null; }
  }
  goal(){
    const ctx=this.ensure(); if(!ctx) return;
    const t0=ctx.currentTime;
    const vol=CONFIG.sound.goalVolume;

    const osc1=ctx.createOscillator();
    const osc2=ctx.createOscillator();
    const gain=ctx.createGain();
    const filter=ctx.createBiquadFilter();

    filter.type='lowpass';
    filter.frequency.setValueAtTime(2200,t0);

    osc1.type='sine';
    osc2.type='triangle';

    osc1.frequency.setValueAtTime(420,t0);
    osc1.frequency.exponentialRampToValueAtTime(780,t0+0.18);
    osc2.frequency.setValueAtTime(220,t0);
    osc2.frequency.exponentialRampToValueAtTime(330,t0+0.18);

    gain.gain.setValueAtTime(0.0001,t0);
    gain.gain.exponentialRampToValueAtTime(vol,t0+0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001,t0+0.35);

    osc1.connect(filter); osc2.connect(filter);
    filter.connect(gain); gain.connect(ctx.destination);

    osc1.start(t0); osc2.start(t0);
    osc1.stop(t0+0.4); osc2.stop(t0+0.4);
  }
}

class Game{
  constructor(canvas){
    this.canvas=canvas;
    this.state={ turn:'A', scoreA:0, scoreB:0, removedA:0, removedB:0, phase:'ready', winner:null };
    this.effects={ goalBannerUntil:0, goalRipple:null, goalPauseUntil:0 };

    this.ball=new Ball(CONFIG.world.w/2, CONFIG.world.h/2);
    this.pegs=[];
    this.buildInitialTeams();

    this.physics=new Physics(this);
    this.sound=new Sound();

    this.renderer=new Renderer(this, canvas);
    this.input=new Input(this, canvas, this.renderer);

    this.undoSnapshot=null;
    this.lastFrameMs=nowMs();
    this.acc=0;

    this.ui={
      scoreA:document.getElementById('scoreA'),
      scoreB:document.getElementById('scoreB'),
      turnText:document.getElementById('turnText'),
      turnPill:document.getElementById('turnPill'),
      btnUndo:document.getElementById('btnUndo'),
      btnReset:document.getElementById('btnReset'),
      btnHelp:document.getElementById('btnHelp'),
      goalBanner:document.getElementById('goalBanner'),
    };

    this.bindUI();
    this.updateHUD();
    this.loop();
  }

  buildInitialTeams(){
    this.pegs=[];
    const W=CONFIG.world.w, H=CONFIG.world.h;

    const formation=(team)=>{
      const baseX=(team==='A')?W*0.22:W*0.78;
      const side=(team==='A')?-1:1;
      const spreadY=90;
      const pts=[];
      pts.push({ x: baseX + side*170, y: H*0.5 });
      const rows=[
        { n:4, x: baseX + side*80,  y: H*0.5, dy: spreadY },
        { n:4, x: baseX,           y: H*0.5, dy: spreadY },
        { n:2, x: baseX - side*100,y: H*0.5, dy: spreadY*0.8 },
      ];
      for(const row of rows){
        for(let i=0;i<row.n;i++){
          const t=(row.n===1)?0:(i/(row.n-1)-0.5);
          pts.push({ x: row.x, y: row.y + t*row.dy*2 });
        }
      }
      for(const p of pts){
        p.x += (Math.random()*2-1)*10;
        p.y += (Math.random()*2-1)*12;
      }
      return pts;
    };

    const ptsA=formation('A');
    const ptsB=formation('B');

    for(let i=0;i<CONFIG.teams.count;i++){
      const p=ptsA[i] || {x:W*0.25, y:H*(0.2+0.6*i/(CONFIG.teams.count-1))};
      this.pegs.push(new Peg(p.x,p.y,'A',`A${i}`));
    }
    for(let i=0;i<CONFIG.teams.count;i++){
      const p=ptsB[i] || {x:W*0.75, y:H*(0.2+0.6*i/(CONFIG.teams.count-1))};
      this.pegs.push(new Peg(p.x,p.y,'B',`B${i}`));
    }
  }

  bindUI(){
    const back=document.getElementById('helpBack');
    const btnClose=document.getElementById('btnCloseHelp');

    this.ui.btnReset.addEventListener('click', ()=>this.resetMatch());
    this.ui.btnUndo.addEventListener('click', ()=>this.undo());
    this.ui.btnHelp.addEventListener('click', ()=>back.classList.add('show'));
    btnClose.addEventListener('click', ()=>back.classList.remove('show'));
    back.addEventListener('click', (e)=>{ if(e.target===back) back.classList.remove('show'); });

    window.addEventListener('pointerdown', ()=>{
      if(CONFIG.sound.enabled){
        const ctx=this.sound.ensure();
        if(ctx && ctx.state==='suspended') ctx.resume().catch(()=>{});
      }
    }, { once:false });
  }

  updateHUD(){
    this.ui.scoreA.textContent=String(this.state.scoreA);
    this.ui.scoreB.textContent=String(this.state.scoreB);
    this.ui.turnText.textContent=(this.state.turn==='A')?'Equipo A':'Equipo B';
    this.ui.turnPill.style.background=(this.state.turn==='A')?'#ff6b6b':'#4da3ff';
    this.ui.btnUndo.disabled=!this.undoSnapshot || (this.state.phase==='simulating') || (this.state.phase==='paused');
  }

  makeSnapshot(){
    return {
      state: deepClone(this.state),
      ball: { p:{x:this.ball.p.x,y:this.ball.p.y}, v:{x:this.ball.v.x,y:this.ball.v.y}, active:this.ball.active },
      pegs: this.pegs.map(p=>({ id:p.id, team:p.team, active:p.active, p:{x:p.p.x,y:p.p.y}, v:{x:p.v.x,y:p.v.y} }))
    };
  }

  applySnapshot(snap){
    this.state=deepClone(snap.state);
    this.ball.p.x=snap.ball.p.x; this.ball.p.y=snap.ball.p.y;
    this.ball.v.x=snap.ball.v.x; this.ball.v.y=snap.ball.v.y;
    this.ball.active=snap.ball.active;

    const map=new Map(this.pegs.map(p=>[p.id,p]));
    for(const sp of snap.pegs){
      const p=map.get(sp.id);
      if(!p) continue;
      p.active=sp.active;
      p.p.x=sp.p.x; p.p.y=sp.p.y;
      p.v.x=sp.v.x; p.v.y=sp.v.y;
    }

    if(this.input.selectedPegObj && !this.input.selectedPegObj.active){
      this.input.selectedPegObj=null;
      this.input.selectedPeg=null;
    }

    this.effects.goalBannerUntil=0;
    this.effects.goalRipple=null;
    this.effects.goalPauseUntil=0;

    this.updateHUD();
  }

  undo(){
    if(!this.undoSnapshot) return;
    if(this.state.phase==='simulating' || this.state.phase==='paused') return;
    this.applySnapshot(this.undoSnapshot);
    this.undoSnapshot=null;
    this.updateHUD();
  }

  getActiveBodies(){ return [this.ball, ...this.pegs.filter(p=>p.active)]; }
  getRenderBodiesSorted(){
    const bodies=[this.ball, ...this.pegs.filter(p=>p.active)];
    bodies.sort((a,b)=>a.p.y-b.p.y);
    return bodies;
  }

  pickPegAt(worldPos, team){
    let best=null, bestD=Infinity;
    for(const p of this.pegs){
      if(!p.active || p.team!==team) continue;
      const d=len(worldPos.x-p.p.x, worldPos.y-p.p.y);
      if(d<=p.r && d<bestD){ bestD=d; best=p; }
    }
    return best;
  }

  allStopped(){
    for(const b of this.getActiveBodies()){
      if(b.speed()>CONFIG.physics.stopSpeed) return false;
    }
    return true;
  }

  tryFlick(peg, dir, impulse){
    if(this.state.phase!=='ready') return;
    if(!peg.active || peg.team!==this.state.turn) return;

    this.undoSnapshot=this.makeSnapshot();

    peg.v.x += dir.x * impulse / peg.mass;
    peg.v.y += dir.y * impulse / peg.mass;

    this.state.phase='simulating';
    this.simStartMs=nowMs();
    this.updateHUD();
  }

  resetMatch(){
    this.undoSnapshot=null;
    this.state={ turn:'A', scoreA:0, scoreB:0, removedA:0, removedB:0, phase:'ready', winner:null };

    this.ball.p.x=CONFIG.world.w/2; this.ball.p.y=CONFIG.world.h/2;
    this.ball.v.x=0; this.ball.v.y=0; this.ball.active=true;

    this.buildInitialTeams();

    this.input.selectedPeg=null;
    this.input.selectedPegObj=null;
    this.input.isAiming=false;

    this.effects.goalBannerUntil=0;
    this.effects.goalRipple=null;
    this.effects.goalPauseUntil=0;

    this.updateHUD();
  }

  forceBallBackIfOut(){
    const W=CONFIG.world.w, H=CONFIG.world.h;
    const b=this.ball, r=b.r, e=CONFIG.physics.wallRestitution;
    if(b.p.x-r<0){ b.p.x=r; b.v.x=Math.abs(b.v.x)*e; }
    if(b.p.x+r>W){ b.p.x=W-r; b.v.x=-Math.abs(b.v.x)*e; }
    if(b.p.y-r<0){ b.p.y=r; b.v.y=Math.abs(b.v.y)*e; }
    if(b.p.y+r>H){ b.p.y=H-r; b.v.y=-Math.abs(b.v.y)*e; }
  }

  checkGoalCorridor(){
    const W=CONFIG.world.w, H=CONFIG.world.h, open=CONFIG.goal.opening;
    const yTop=(H-open)/2, yBot=yTop+open;
    const b=this.ball;
    const inMouth=(b.p.y>=yTop && b.p.y<=yBot);

    if(inMouth && (b.p.x + b.r < 0)) return { side:'left', scorer:'B', conceded:'A' };
    if(inMouth && (b.p.x - b.r > W)) return { side:'right', scorer:'A', conceded:'B' };

    if(b.p.x - b.r < 0){
      if(!inMouth){ b.p.x=b.r; b.v.x=Math.abs(b.v.x)*CONFIG.physics.wallRestitution; }
      else b.p.x -= Math.max(0, Math.abs(b.v.x))*CONFIG.physics.dt*1.1;
    }
    if(b.p.x + b.r > W){
      if(!inMouth){ b.p.x=W-b.r; b.v.x=-Math.abs(b.v.x)*CONFIG.physics.wallRestitution; }
      else b.p.x += Math.max(0, Math.abs(b.v.x))*CONFIG.physics.dt*1.1;
    }
    if(b.p.y - b.r < 0){ b.p.y=b.r; b.v.y=Math.abs(b.v.y)*CONFIG.physics.wallRestitution; }
    if(b.p.y + b.r > H){ b.p.y=H-b.r; b.v.y=-Math.abs(b.v.y)*CONFIG.physics.wallRestitution; }

    return null;
  }

  applyGoal(goal){
    if(this.state.phase==='gameover') return;

    if(goal.scorer==='A') this.state.scoreA+=1; else this.state.scoreB+=1;
    if(goal.conceded==='A') this.state.removedA+=1; else this.state.removedB+=1;

    const conceded=goal.conceded;
    const teamPegs=this.pegs.filter(p=>p.active && p.team===conceded);
    if(teamPegs.length){
      let best=null, bestScore=-Infinity;
      for(const p of teamPegs){
        const dBall=len(p.p.x-this.ball.p.x, p.p.y-this.ball.p.y);
        const dCenter=len(p.p.x-CONFIG.world.w/2, p.p.y-CONFIG.world.h/2);
        const score=dBall*0.6 + dCenter*0.4;
        if(score>bestScore){ bestScore=score; best=p; }
      }
      best.active=false;
      best.v.x=best.v.y=0;
    }

    this.effects.goalBannerUntil=nowMs()+CONFIG.effects.goalBannerMs;
    this.effects.goalRipple={ side: goal.side, t0: nowMs() };
    this.sound.goal();

    if(this.state.scoreA>=11 || this.state.scoreB>=11){
      this.state.phase='gameover';
      this.state.winner=(this.state.scoreA>=11)?'A':'B';
    }

    this.resetAfterGoal(goal.side);
  }

  resetAfterGoal(side){
    for(const b of this.getActiveBodies()){ b.v.x=0; b.v.y=0; }
    this.ball.p.x=CONFIG.world.w/2; this.ball.p.y=CONFIG.world.h/2;
    this.ball.p.x += (side==='left') ? 2 : -2;

    this.effects.goalPauseUntil=nowMs()+CONFIG.effects.goalPauseMs;
    this.state.phase='paused';
    this.switchTurn();
    this.updateHUD();
    this.input.isAiming=false;
  }

  switchTurn(){ this.state.turn=(this.state.turn==='A')?'B':'A'; }
  finishTurn(){
    if(this.state.phase==='gameover') return;
    this.state.phase='ready';
    this.switchTurn();
    this.updateHUD();
  }

  loop(){
    const t=nowMs();
    const dtFrame=(t-this.lastFrameMs)/1000;
    this.lastFrameMs=t;

    const capped=Math.min(dtFrame,0.05);
    this.acc += capped;

    if(this.state.phase==='paused'){
      if(t>=this.effects.goalPauseUntil){
        if(this.state.phase!=='gameover'){ this.state.phase='ready'; this.updateHUD(); }
      }
    }

    if(this.state.phase==='simulating'){
      let steps=0;
      const fixed=CONFIG.physics.dt;

      while(this.acc>=fixed && steps<CONFIG.physics.maxSubStepsPerFrame){
        this.physics.step(fixed);
        this.forceBallBackIfOut();
        this.acc -= fixed;
        steps++;
      }

      const goal=this.checkGoalCorridor();
      if(goal){
        this.applyGoal(goal);
      } else {
        const elapsed=(t-this.simStartMs)/1000;
        if(this.allStopped() || elapsed>=CONFIG.physics.sleepTimeMax){
          for(const b of this.getActiveBodies()){ b.v.x=0; b.v.y=0; }
          this.finishTurn();
        }
      }
    }

    if(t<this.effects.goalBannerUntil) this.ui.goalBanner.classList.add('show');
    else this.ui.goalBanner.classList.remove('show');

    this.renderer.draw();

    if(this.state.phase==='gameover') this.drawGameOverOverlay();
    this.updateHUD();

    requestAnimationFrame(()=>this.loop());
  }

  drawGameOverOverlay(){
    const ctx=this.renderer.ctx;
    const w=this.canvas.width, h=this.canvas.height;
    const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,.35)';
    ctx.fillRect(0,0,w,h);

    const text=(this.state.winner==='A')?'¡GANA EQUIPO A!':'¡GANA EQUIPO B!';
    ctx.font=`900 ${Math.floor(54*dpr)}px ui-sans-serif,system-ui`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillStyle='rgba(255,255,255,.92)';
    ctx.shadowColor='rgba(0,0,0,.45)';
    ctx.shadowBlur=18*dpr;
    ctx.fillText(text,w/2,h/2-22*dpr);

    ctx.shadowBlur=0;
    ctx.font=`700 ${Math.floor(16*dpr)}px ui-sans-serif,system-ui`;
    ctx.fillStyle='rgba(234,240,255,.85)';
    ctx.fillText('Pulsa “Reiniciar partido” para jugar otra vez.',w/2,h/2+28*dpr);

    ctx.restore();
  }
}

/* ✅ Mostrar errores en overlay */
function showErr(e){
  const box=document.getElementById('err');
  if(!box) return;
  box.style.display='block';
  box.textContent='ERROR: ' + (e?.stack || e?.message || String(e));
}

/* ✅ Arranque protegido + render inicial inmediato */
try{
  const canvas=document.getElementById('game');
  if(!canvas) throw new Error('No encuentro <canvas id="game">');

  const game=new Game(canvas);

  // Forzar render inicial
  game.renderer.draw();
}catch(e){
  showErr(e);
}

/*
============================================================
CÓMO JUGAR
============================================================
- Turnos alternos: Equipo A y Equipo B.
- En tu turno: click sobre uno de tus palitos para seleccionarlo.
- Mantén pulsado y arrastra para apuntar y definir potencia.
- Suelta para chutar (tirachinas).
- El turno termina cuando todo se detiene, hay gol o se alcanza el tiempo máximo.
- Gol: la bola entra completamente en la portería rival.
  El equipo que encaja retira 1 palito y el rival suma 1 al marcador.
- Gana quien llegue a 11 goles.

============================================================
PARÁMETROS RECOMENDADOS (CONFIG)
============================================================
- CONFIG.flick.maxImpulse: fuerza máxima.
- CONFIG.flick.maxDrag: distancia máxima de arrastre.
- CONFIG.physics.wallRestitution: rebote.
- CONFIG.ball.linearDamp / CONFIG.peg.linearDamp: fricción.
- CONFIG.physics.stopSpeed: umbral de parada.
- CONFIG.goal.opening: boca de la portería.
*/
</script>
</body>
</html>
