<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PLAKKS-like Flick Soccer (Ball Flick)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#eaf0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .wrap{height:100%;display:flex;flex-direction:column;padding:12px;gap:10px;max-width:1200px;margin:0 auto;}
    .top{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .title{font-weight:900;letter-spacing:.2px;font-size:15px;display:flex;gap:10px;align-items:center}
    .badge{font-weight:800;font-size:12px;padding:3px 8px;border-radius:999px;background:rgba(125,211,252,.14);border:1px solid rgba(125,211,252,.35);color:#c9f2ff}
    .sub{font-size:12px;opacity:.75;margin-top:2px}
    .hud{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    .score{
      display:flex;align-items:center;gap:10px;padding:8px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);
      min-width:190px;justify-content:space-between
    }
    .teamTag{display:flex;align-items:center;gap:8px;font-weight:900;font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%;box-shadow:0 0 0 3px rgba(255,255,255,.06)}
    .dotA{background:#4da3ff} /* A azul */
    .dotB{background:#ff6b6b} /* B rojo */
    .scoreNum{font-weight:1000;font-size:20px;letter-spacing:.6px}
    .turn{
      padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);font-weight:900;font-size:12px;display:flex;gap:8px;align-items:center
    }
    .pill{width:10px;height:10px;border-radius:50%;box-shadow:0 0 0 3px rgba(255,255,255,.06)}
    .btnRow{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    button{
      cursor:pointer;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);color:#eaf0ff;
      padding:8px 10px;border-radius:12px;font-weight:800;font-size:12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 10px 20px rgba(0,0,0,.18);
    }
    button:active{transform:translateY(1px)}
    button.secondary{border-color:rgba(167,139,250,.35);background:rgba(167,139,250,.12)}
    button.danger{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.12)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .shell{
      position:relative;flex:1;border-radius:16px;border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);overflow:hidden;min-height:520px;
      box-shadow: 0 18px 42px rgba(0,0,0,.32);
    }
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:#091022}
    .note{
      position:absolute;left:12px;bottom:10px;z-index:5;
      padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.10);font-size:12px;line-height:1.35;max-width:min(560px,calc(100% - 24px));
      color:rgba(234,240,255,.8)
    }
    .note b{color:#fff}
    .dbg{
      position:absolute;left:12px;top:12px;z-index:10;padding:8px 10px;border-radius:12px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);font:800 12px/1.35 system-ui;
      display:none;
    }
    .goalBanner{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;
      opacity:0;transition:opacity .18s ease;z-index:8;
    }
    .goalBanner.show{opacity:1}
    .goalText{
      font-weight:1000;letter-spacing:2px;font-size:clamp(44px,7vw,92px);
      padding:10px 22px;border-radius:20px;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.15);
      box-shadow:0 24px 80px rgba(0,0,0,.45);text-shadow:0 16px 30px rgba(0,0,0,.45);
      transform:translateY(10px) scale(.98);transition:transform .18s ease;
    }
    .goalBanner.show .goalText{transform:translateY(0) scale(1)}
    .modalBack{
      position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:16px;z-index:50;
    }
    .modalBack.show{display:flex}
    .modal{
      width:min(760px,100%);border-radius:16px;border:1px solid rgba(255,255,255,.12);
      background:rgba(15,26,47,.96);box-shadow:0 30px 100px rgba(0,0,0,.55);
      padding:16px 16px 12px;
    }
    .modal h2{margin:0 0 8px;font-size:16px}
    .modal p,.modal li{font-size:13px;line-height:1.45;color:rgba(234,240,255,.85)}
    .modal ul{margin:8px 0 0 18px}
    .modal .top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px;padding:0;border:0;background:none;box-shadow:none}
    @media(max-width:720px){
      .top{flex-direction:column;align-items:stretch}
      .btnRow button{flex:1}
      .shell{min-height:62vh}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <div class="title">PLAKKS-like Flick Soccer <span class="badge">ball flick</span></div>
      <div class="sub">Chutas la bola · Los palitos de ambos equipos estorban · Gol = quitas 1 palito al rival</div>
    </div>
    <div class="hud">
      <div class="score" aria-label="Marcador">
        <div class="teamTag"><span class="dot dotA"></span>Equipo A</div>
        <div class="scoreNum"><span id="scoreA">0</span> – <span id="scoreB">0</span></div>
        <div class="teamTag">Equipo B<span class="dot dotB"></span></div>
      </div>
      <div class="turn" aria-label="Turno">
        <span>Turno:</span><span class="pill" id="turnPill"></span><span id="turnText">Equipo A</span>
      </div>
      <div class="btnRow">
        <button id="undo" class="secondary">Deshacer último tiro</button>
        <button id="reset" class="danger">Reiniciar partido</button>
        <button id="help">Ayuda</button>
      </div>
    </div>
  </div>

  <div class="shell" id="shell">
    <canvas id="c"></canvas>
    <div class="dbg" id="dbg"></div>
    <div class="goalBanner" id="goalBanner"><div class="goalText">GOOOL</div></div>
    <div class="note">
      <b>Cómo chutar:</b> toca/click en la <b>bola</b> → arrastra para marcar <b>dirección</b> y <b>potencia</b> → suelta.<br/>
      <span style="opacity:.9">El saque sale desde una esquina de tu campo (se elige aleatoria). Los palitos de tu equipo también estorban.</span>
    </div>
  </div>
</div>

<div class="modalBack" id="helpBack" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="modal">
    <div class="top">
      <h2 id="helpTitle">Ayuda · Reglas y controles</h2>
      <button id="closeHelp">Cerrar</button>
    </div>
    <p><b>Objetivo:</b> meter gol con la bola. Los palitos (de ambos equipos) hacen de obstáculos.</p>
    <ul>
      <li><b>Turnos:</b> alternan A/B. En tu turno haces <b>un</b> chute con la <b>bola</b>.</li>
      <li><b>Saque:</b> en tu turno, la bola aparece en <b>una esquina de tu campo</b> (aleatoria).</li>
      <li><b>Control:</b> selecciona la bola → arrastra en la dirección del tiro (potencia = distancia) → suelta.</li>
      <li><b>Gol:</b> si la bola entra completamente en la portería rival.</li>
      <li><b>Al gol:</b> se quita 1 palito del equipo que encaja y se deja apoyado en el borde (visible).</li>
      <li><b>Gana:</b> quien llega a 11 goles (deja al rival sin palitos).</li>
    </ul>
  </div>
</div>

<script>
(() => {
  /* =========================
     CONFIG (ajustable)
  ========================= */
  const CONFIG = {
    debug: { enabled: false },

    world: { w: 1200, h: 720 },

    goal: { opening: 220, depth: 46, postRadius: 10 },

    ball: { r: 16, mass: 1.0, restitution: 0.90, damp: 0.994, maxSpeed: 2600 },

    peg:  { r: 24, mass: 5.0, restitution: 0.55, damp: 0.992, maxSpeed: 2200 },

    teams: { count: 11 },

    shot: {
      maxDrag: 210,        // píxeles CSS aprox (se escala con dpr internamente)
      minImpulse: 280,
      maxImpulse: 2200,
      aimLineW: 3
    },

    physics: {
      dt: 1/120,
      maxSubStepsPerFrame: 10,
      solverIterations: 5,
      wallRestitution: 0.86,
      stopSpeed: 14,
      maxSimSeconds: 4.0,
      penetrationSlop: 0.02,
      penetrationPercent: 0.92,
    },

    render: {
      pitchMargin: 34,
      pitchCornerR: 38,
      grassNoise: 0.06,
      shadowOffset: { x: 10, y: 14 },
      shadowBlur: 16,
      vignette: true,

      removed: {
        // palitos retirados se apoyan en el borde (izq para A, der para B)
        scale: 0.72,
        alpha: 0.68,
        pad: 10,
        gap: 8,
      }
    },

    effects: { goalBannerMs: 850, goalPauseMs: 520 },
  };

  /* =========================
     Utils
  ========================= */
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const hypot = (x,y) => Math.hypot(x,y);
  const nowMs = () => performance.now();
  const rand = (a,b)=>a+Math.random()*(b-a);

  class Vec2{
    constructor(x=0,y=0){this.x=x;this.y=y;}
    mag(){return Math.hypot(this.x,this.y);}
    mul(s){this.x*=s;this.y*=s;return this;}
    dot(v){return this.x*v.x+this.y*v.y;}
    static sub(a,b){return new Vec2(a.x-b.x,a.y-b.y);}
    static mul(a,s){return new Vec2(a.x*s,a.y*s);}
  }

  class Body{
    constructor(x,y,r,mass){
      this.p=new Vec2(x,y);
      this.v=new Vec2(0,0);
      this.r=r;
      this.mass=mass;
      this.invMass=mass>0?1/mass:0;
      this.restitution=0.8;
      this.damp=0.995;
      this.maxSpeed=2000;
      this.active=true;
    }
    speed(){return this.v.mag();}
  }

  class Ball extends Body{
    constructor(x,y){
      super(x,y,CONFIG.ball.r,CONFIG.ball.mass);
      this.restitution=CONFIG.ball.restitution;
      this.damp=CONFIG.ball.damp;
      this.maxSpeed=CONFIG.ball.maxSpeed;
    }
  }

  class Peg extends Body{
    constructor(x,y,team,id){
      super(x,y,CONFIG.peg.r,CONFIG.peg.mass);
      this.team=team;
      this.id=id;
      this.restitution=CONFIG.peg.restitution;
      this.damp=CONFIG.peg.damp;
      this.maxSpeed=CONFIG.peg.maxSpeed;
    }
  }

  class Physics{
    constructor(game){this.game=game;}
    step(dt){
      const bodies=this.game.getActiveBodies();
      const W=CONFIG.world.w, H=CONFIG.world.h;

      for(const b of bodies){
        b.p.x += b.v.x*dt;
        b.p.y += b.v.y*dt;

        b.v.mul(b.damp);

        const s=b.speed();
        if(s>b.maxSpeed){
          const k=b.maxSpeed/(s+1e-9);
          b.v.mul(k);
        }

        const e=CONFIG.physics.wallRestitution;

        // Rebotes en límites del campo (la "salida" por portería se detecta aparte)
        if(b.p.x-b.r<0){ b.p.x=b.r; b.v.x=Math.abs(b.v.x)*e; }
        if(b.p.x+b.r>W){ b.p.x=W-b.r; b.v.x=-Math.abs(b.v.x)*e; }
        if(b.p.y-b.r<0){ b.p.y=b.r; b.v.y=Math.abs(b.v.y)*e; }
        if(b.p.y+b.r>H){ b.p.y=H-b.r; b.v.y=-Math.abs(b.v.y)*e; }
      }

      for(let it=0; it<CONFIG.physics.solverIterations; it++){
        for(let i=0;i<bodies.length;i++){
          for(let j=i+1;j<bodies.length;j++){
            this.resolveCircles(bodies[i], bodies[j]);
          }
        }
      }
    }

    resolveCircles(a,b){
      if(!a.active || !b.active) return;

      const n=Vec2.sub(b.p,a.p);
      let dist=n.mag();
      const r=a.r+b.r;
      if(dist<=0) dist=0.0001;

      if(dist<r){
        const penetration=r-dist;
        const normal=n.mul(1/dist);
        const invMassSum=a.invMass+b.invMass;
        if(invMassSum<=0) return;

        // corrección penetración
        const slop=CONFIG.physics.penetrationSlop;
        const percent=CONFIG.physics.penetrationPercent;
        const corr=Math.max(penetration-slop,0)/invMassSum*percent;

        a.p.x -= normal.x*corr*a.invMass;
        a.p.y -= normal.y*corr*a.invMass;
        b.p.x += normal.x*corr*b.invMass;
        b.p.y += normal.y*corr*b.invMass;

        // impulso
        const rv=new Vec2(b.v.x-a.v.x, b.v.y-a.v.y);
        const velAlongNormal=rv.dot(normal);

        if(velAlongNormal<0){
          const e=Math.min(a.restitution,b.restitution);
          let j=-(1+e)*velAlongNormal;
          j/=invMassSum;

          const imp=Vec2.mul(normal,j);
          a.v.x -= imp.x*a.invMass; a.v.y -= imp.y*a.invMass;
          b.v.x += imp.x*b.invMass; b.v.y += imp.y*b.invMass;

          // fricción tangencial pequeña
          const tangent=new Vec2(rv.x-velAlongNormal*normal.x, rv.y-velAlongNormal*normal.y);
          const tmag=tangent.mag();
          if(tmag>1e-6){
            tangent.mul(1/tmag);
            const jt=-rv.dot(tangent)*0.025;
            const timp=Vec2.mul(tangent,jt);
            a.v.x -= timp.x*a.invMass; a.v.y -= timp.y*a.invMass;
            b.v.x += timp.x*b.invMass; b.v.y += timp.y*b.invMass;
          }
        }
      }
    }
  }

  class Renderer{
    constructor(game,canvas,shell){
      this.game=game;
      this.canvas=canvas;
      this.shell=shell;
      this.ctx=canvas.getContext('2d');

      this.noise=document.createElement('canvas');
      this.noise.width=256; this.noise.height=256;
      this.noiseCtx=this.noise.getContext('2d');
      this.buildNoise();

      this.scale=1;
      this.ox=0; this.oy=0;
      this.w=0; this.h=0; this.dpr=1;
    }

    buildNoise(){
      const img=this.noiseCtx.createImageData(256,256);
      for(let i=0;i<img.data.length;i+=4){
        const n=(Math.random()*2-1)*255;
        img.data[i]=0;
        img.data[i+1]=120+n*0.08;
        img.data[i+2]=0;
        img.data[i+3]=255;
      }
      this.noiseCtx.putImageData(img,0,0);
    }

    resize(){
      const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
      const r=this.shell.getBoundingClientRect();
      const cssW=Math.max(300, r.width||900);
      const cssH=Math.max(300, r.height||540);

      const w=Math.floor(cssW*dpr);
      const h=Math.floor(cssH*dpr);

      if(this.canvas.width!==w || this.canvas.height!==h){
        this.canvas.width=w; this.canvas.height=h;
      }

      const pad=CONFIG.render.pitchMargin*dpr;
      const sx=(w-pad*2)/CONFIG.world.w;
      const sy=(h-pad*2)/CONFIG.world.h;
      const scale=Math.max(0.0001, Math.min(sx,sy));

      this.dpr=dpr;
      this.w=w; this.h=h;
      this.scale=scale;
      this.ox=(w-CONFIG.world.w*scale)*0.5;
      this.oy=(h-CONFIG.world.h*scale)*0.5;
    }

    w2s(p){ return { x:this.ox+p.x*this.scale, y:this.oy+p.y*this.scale }; }
    s2w(p){ return { x:(p.x-this.ox)/this.scale, y:(p.y-this.oy)/this.scale }; }

    roundRect(x,y,w,h,r){
      const ctx=this.ctx;
      const rr=Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    drawPitch(){
      const ctx=this.ctx;
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const x0=this.ox, y0=this.oy, s=this.scale;

      const g=ctx.createLinearGradient(x0,y0,x0+W*s,y0+H*s);
      g.addColorStop(0,'#0f6b3c');
      g.addColorStop(0.5,'#0e5f37');
      g.addColorStop(1,'#0b4a2c');

      const r=CONFIG.render.pitchCornerR*this.dpr;
      ctx.save();
      ctx.fillStyle=g;
      this.roundRect(x0,y0,W*s,H*s,r);
      ctx.fill();

      ctx.globalAlpha=0.13;
      for(let i=0;i<10;i++){
        const yy=y0+(H*s)*(i/10);
        ctx.fillStyle=(i%2===0)?'#0b4f2f':'#0f7343';
        ctx.fillRect(x0,yy,W*s,(H*s)/10);
      }
      ctx.globalAlpha=1;

      ctx.globalAlpha=CONFIG.render.grassNoise;
      ctx.drawImage(this.noise,x0,y0,W*s,H*s);
      ctx.globalAlpha=1;

      ctx.lineWidth=3*this.dpr;
      ctx.strokeStyle='rgba(245,255,245,.85)';
      this.roundRect(x0+2*this.dpr,y0+2*this.dpr,W*s-4*this.dpr,H*s-4*this.dpr,Math.max(2,r-6*this.dpr));
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x0+(W*s)/2, y0+2*this.dpr);
      ctx.lineTo(x0+(W*s)/2, y0+H*s-2*this.dpr);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x0+(W*s)/2,y0+(H*s)/2,110*s,0,Math.PI*2);
      ctx.stroke();

      ctx.fillStyle='rgba(245,255,245,.95)';
      ctx.beginPath();
      ctx.arc(x0+(W*s)/2,y0+(H*s)/2,5*this.dpr,0,Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    drawGoals(){
      const ctx=this.ctx;
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const open=CONFIG.goal.opening;
      const depth=CONFIG.goal.depth;
      const postR=CONFIG.goal.postRadius;
      const s=this.scale;

      const drawOne = (side) => {
        const dir = (side==='left')? 1 : -1;
        const cx  = (side==='left')? 0 : W;
        const yTop=(H-open)/2;
        const yBot=yTop+open;

        const xEdge=this.ox+cx*s;
        const yT=this.oy+yTop*s;
        const yB=this.oy+yBot*s;
        const d=depth*s;

        ctx.save();
        ctx.lineWidth=2.5*this.dpr;
        ctx.strokeStyle='rgba(255,255,255,.32)';
        ctx.beginPath();
        ctx.moveTo(xEdge+dir*d, yT+d*0.18);
        ctx.lineTo(xEdge+dir*d, yB-d*0.18);
        ctx.stroke();

        ctx.globalAlpha=0.22;
        ctx.strokeStyle='rgba(255,255,255,.75)';
        for(let i=0;i<10;i++){
          const t=i/9;
          const yy=lerp(yT+6*this.dpr,yB-6*this.dpr,t);
          ctx.beginPath();
          ctx.moveTo(xEdge,yy);
          ctx.lineTo(xEdge+dir*d,yy+d*0.10*dir);
          ctx.stroke();
        }
        ctx.globalAlpha=1;

        const postX=xEdge+dir*(postR*s*0.15);
        const rr=postR*s;

        const drawPost = (x,y) => {
          const grd=ctx.createRadialGradient(x-rr*0.4,y-rr*0.4,rr*0.3,x,y,rr*1.05);
          grd.addColorStop(0,'rgba(255,255,255,.95)');
          grd.addColorStop(0.6,'rgba(255,255,255,.55)');
          grd.addColorStop(1,'rgba(255,255,255,.25)');
          ctx.fillStyle=grd;
          ctx.beginPath(); ctx.arc(x,y,rr,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle='rgba(0,0,0,.22)';
          ctx.lineWidth=1.2*this.dpr;
          ctx.stroke();
        };

        drawPost(postX,yT);
        drawPost(postX,yB);

        ctx.lineWidth=6*this.dpr;
        ctx.strokeStyle='rgba(255,255,255,.65)';
        ctx.beginPath();
        ctx.moveTo(postX,yT);
        ctx.lineTo(postX,yB);
        ctx.stroke();

        ctx.restore();
      };

      drawOne('left');
      drawOne('right');
    }

    drawShadowAt(x,y,r,alpha=0.35){
      const ctx=this.ctx;
      const off=CONFIG.render.shadowOffset;
      const sx=x+off.x*this.dpr;
      const sy=y+off.y*this.dpr;
      ctx.save();
      ctx.globalAlpha=alpha;
      ctx.fillStyle='rgba(0,0,0,.55)';
      ctx.shadowColor='rgba(0,0,0,.55)';
      ctx.shadowBlur=CONFIG.render.shadowBlur*this.dpr;
      ctx.beginPath();
      ctx.ellipse(sx,sy,r*1.05,r*0.78,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    drawBall(ball, selected){
      const ctx=this.ctx;
      const p=this.w2s(ball.p);
      const r=ball.r*this.scale;

      this.drawShadowAt(p.x,p.y,r,0.40);

      ctx.save();
      const g=ctx.createRadialGradient(p.x-r*0.35,p.y-r*0.35,r*0.35,p.x,p.y,r*1.15);
      g.addColorStop(0,'rgba(255,255,255,.98)');
      g.addColorStop(0.35,'rgba(255,255,255,.92)');
      g.addColorStop(0.7,'rgba(220,230,255,.88)');
      g.addColorStop(1,'rgba(140,160,190,.85)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.18)';
      ctx.lineWidth=1.3*this.dpr;
      ctx.stroke();

      ctx.globalAlpha=0.55;
      ctx.fillStyle='rgba(255,255,255,.85)';
      ctx.beginPath();
      ctx.ellipse(p.x-r*0.25,p.y-r*0.35,r*0.35,r*0.25,-0.6,0,Math.PI*2);
      ctx.fill();

      if(selected){
        ctx.globalAlpha=1;
        ctx.strokeStyle='rgba(125,211,252,.95)';
        ctx.lineWidth=3*this.dpr;
        ctx.beginPath();
        ctx.arc(p.x,p.y,r+4*this.dpr,0,Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
    }

    drawPegScreen(x,y,rScreen,team,dimmed=false,alpha=1){
      const ctx=this.ctx;
      // A azul (como foto), B rojo
      const base=(team==='A')?{a:'#4da3ff',b:'#124fae'}:{a:'#ff6b6b',b:'#b81f3d'};

      ctx.save();
      ctx.globalAlpha = alpha;

      const g=ctx.createRadialGradient(x-rScreen*0.35,y-rScreen*0.25,rScreen*0.2,x,y,rScreen*1.15);
      g.addColorStop(0,'rgba(255,255,255,.55)');
      g.addColorStop(0.18,base.a);
      g.addColorStop(1,base.b);

      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(x,y,rScreen,0,Math.PI*2); ctx.fill();

      ctx.globalAlpha = alpha * (dimmed ? 0.40 : 0.55);
      const hg=ctx.createLinearGradient(x-rScreen*0.7,y-rScreen*0.2,x+rScreen*0.7,y+rScreen*0.2);
      hg.addColorStop(0,'rgba(255,255,255,.0)');
      hg.addColorStop(0.38,'rgba(255,255,255,.42)');
      hg.addColorStop(0.62,'rgba(255,255,255,.12)');
      hg.addColorStop(1,'rgba(255,255,255,.0)');
      ctx.fillStyle=hg;
      ctx.beginPath();
      ctx.ellipse(x-rScreen*0.1,y-rScreen*0.1,rScreen*0.9,rScreen*0.55,-0.55,0,Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = alpha;
      ctx.strokeStyle='rgba(0,0,0,.22)';
      ctx.lineWidth=1.2*this.dpr;
      ctx.stroke();

      if(dimmed){
        ctx.globalAlpha = alpha * 0.25;
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        ctx.beginPath(); ctx.arc(x,y,rScreen,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = alpha;
      }

      ctx.restore();
    }

    drawPeg(peg){
      const p=this.w2s(peg.p);
      const r=peg.r*this.scale;
      this.drawShadowAt(p.x,p.y,r,0.34);
      this.drawPegScreen(p.x,p.y,r,peg.team,false,1);
    }

    drawAim(input){
      if(!input.aiming || !input.ballSelected) return;
      const ctx=this.ctx;

      const ball=this.game.ball;
      const bp=this.w2s(ball.p);
      const m=input.mouse;
      const dx=m.x-bp.x, dy=m.y-bp.y;
      const dist=Math.hypot(dx,dy);

      const maxD=CONFIG.shot.maxDrag*this.dpr;
      const clamped=Math.min(dist,maxD);
      const t=clamp(clamped/maxD,0,1);

      ctx.save();
      ctx.lineWidth=CONFIG.shot.aimLineW*this.dpr;
      ctx.lineCap='round';
      ctx.strokeStyle=`rgba(125,211,252,${0.20+0.65*t})`;
      ctx.shadowColor='rgba(0,0,0,.35)';
      ctx.shadowBlur=10*this.dpr;

      // línea hacia el punto de arrastre (dirección del tiro)
      const k=(dist>1e-6)?(clamped/dist):0;
      const ex=bp.x+dx*k, ey=bp.y+dy*k;

      ctx.beginPath();
      ctx.moveTo(bp.x,bp.y);
      ctx.lineTo(ex,ey);
      ctx.stroke();

      // flecha
      const ang=Math.atan2(dy,dx);
      const ah=10*this.dpr;
      ctx.beginPath();
      ctx.moveTo(ex,ey);
      ctx.lineTo(ex-Math.cos(ang-0.55)*ah, ey-Math.sin(ang-0.55)*ah);
      ctx.lineTo(ex-Math.cos(ang+0.55)*ah, ey-Math.sin(ang+0.55)*ah);
      ctx.closePath();
      ctx.fillStyle=`rgba(125,211,252,${0.25+0.60*t})`;
      ctx.fill();

      // barra potencia
      const bw=190*this.dpr, bh=10*this.dpr;
      const bx=this.ox+14*this.dpr, by=this.oy+(CONFIG.world.h*this.scale)-20*this.dpr;
      ctx.shadowBlur=0;
      ctx.fillStyle='rgba(0,0,0,.25)';
      this.roundRect(bx,by,bw,bh,6*this.dpr); ctx.fill();

      const pw=bw*t;
      const pg=ctx.createLinearGradient(bx,by,bx+bw,by);
      pg.addColorStop(0,'rgba(52,211,153,.9)');
      pg.addColorStop(0.55,'rgba(125,211,252,.9)');
      pg.addColorStop(1,'rgba(251,113,133,.9)');
      ctx.fillStyle=pg;
      this.roundRect(bx,by,pw,bh,6*this.dpr); ctx.fill();

      ctx.restore();
    }

    drawRemovedOnBorders(){
      const remCfg=CONFIG.render.removed;
      const pad=remCfg.pad*this.dpr;
      const gap=remCfg.gap*this.dpr;

      const leftEdge = this.ox; // borde del césped
      const rightEdge = this.ox + CONFIG.world.w*this.scale;

      const listA = this.game.pegs.filter(p=>!p.active && p.team==='A');
      const listB = this.game.pegs.filter(p=>!p.active && p.team==='B');

      const rNormal = CONFIG.peg.r*this.scale;
      const r = Math.max(6*this.dpr, rNormal*remCfg.scale);
      const step = (2*r + gap);

      // Apoyados en el "borde" (madera): fuera del césped, pero cerca.
      const xA = Math.max(pad + r, leftEdge - (r + 10*this.dpr));
      const xB = Math.min(this.w - (pad + r), rightEdge + (r + 10*this.dpr));

      const startY = pad + 30*this.dpr;

      const drawStack = (team, list, x) => {
        for(let i=0;i<list.length;i++){
          const y = startY + i*step;
          if(y + r > this.h - pad) break;

          this.drawShadowAt(x,y,r,0.18);
          this.drawPegScreen(x,y,r,team,true,remCfg.alpha);
        }

        // contador si no caben
        const max = Math.floor((this.h - (startY+pad)) / step);
        if(list.length > max){
          const ctx=this.ctx;
          ctx.save();
          ctx.fillStyle='rgba(0,0,0,.35)';
          this.roundRect(x - 22*this.dpr, this.h - (pad+22*this.dpr), 44*this.dpr, 22*this.dpr, 8*this.dpr);
          ctx.fill();
          ctx.fillStyle='rgba(234,240,255,.9)';
          ctx.font=`${Math.floor(12*this.dpr)}px system-ui`;
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText(`+${list.length-max}`, x, this.h - (pad+11*this.dpr));
          ctx.restore();
        }
      };

      drawStack('A', listA, xA);
      drawStack('B', listB, xB);
    }

    drawVignette(){
      if(!CONFIG.render.vignette) return;
      const ctx=this.ctx;
      const w=this.w, h=this.h;
      const g=ctx.createRadialGradient(w*0.5,h*0.5,Math.min(w,h)*0.25,w*0.5,h*0.5,Math.max(w,h)*0.65);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,'rgba(0,0,0,.35)');
      ctx.save();
      ctx.fillStyle=g;
      ctx.fillRect(0,0,w,h);
      ctx.restore();
    }

    draw(){
      this.resize();
      const ctx=this.ctx;
      ctx.clearRect(0,0,this.w,this.h);

      this.drawPitch();
      this.drawGoals();

      // Orden por Y para pseudo-3D
      const bodies=[...this.game.pegs.filter(p=>p.active), this.game.ball];
      bodies.sort((a,b)=>a.p.y-b.p.y);

      for(const b of bodies){
        if(b instanceof Ball) continue;
        this.drawPeg(b);
      }

      this.drawBall(this.game.ball, this.game.input.ballSelected);

      // Palitos retirados apoyados en el borde
      this.drawRemovedOnBorders();

      // Aim UI
      this.drawAim(this.game.input);

      this.drawVignette();

      if(CONFIG.debug.enabled){
        const dbg=this.game.ui.dbg;
        dbg.style.display='block';
        dbg.textContent=`scale ${this.scale.toFixed(4)} dpr ${this.dpr.toFixed(2)} phase ${this.game.phase}`;
      }
    }
  }

  class Input{
    constructor(game,canvas,renderer){
      this.game=game;
      this.canvas=canvas;
      this.r=renderer;

      this.mouse={x:0,y:0};
      this.pointerDown=false;
      this.aiming=false;
      this.ballSelected=false;

      canvas.addEventListener('pointerdown', (e)=>this.onDown(e));
      window.addEventListener('pointermove', (e)=>this.onMove(e), {passive:true});
      window.addEventListener('pointerup', (e)=>this.onUp(e));
      canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
      canvas.addEventListener('touchmove', (e)=>e.preventDefault(), {passive:false});
    }

    pos(e){
      const rect=this.canvas.getBoundingClientRect();
      const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
      return { x:(e.clientX-rect.left)*dpr, y:(e.clientY-rect.top)*dpr };
    }

    onDown(e){
      if(this.game.phase!=='ready') return;
      if(!this.game.canShootNow()) return;

      this.canvas.setPointerCapture?.(e.pointerId);
      this.pointerDown=true;
      this.mouse=this.pos(e);

      // Solo se puede seleccionar la bola
      const wpos=this.r.s2w(this.mouse);
      const b=this.game.ball;
      const d=hypot(wpos.x-b.p.x,wpos.y-b.p.y);

      if(d<=b.r*1.25){
        this.ballSelected=true;
        this.aiming=true;
      }else{
        this.ballSelected=false;
        this.aiming=false;
      }
    }

    onMove(e){
      this.mouse=this.pos(e);
    }

    onUp(e){
      if(!this.pointerDown) return;
      this.pointerDown=false;

      if(!this.aiming || !this.ballSelected) { this.aiming=false; return; }
      if(this.game.phase!=='ready') { this.aiming=false; return; }
      if(!this.game.canShootNow()) { this.aiming=false; return; }

      const ball=this.game.ball;
      const bp=this.r.w2s(ball.p);

      const dx=this.mouse.x-bp.x, dy=this.mouse.y-bp.y;
      const dist=Math.hypot(dx,dy);

      const maxD=CONFIG.shot.maxDrag*this.r.dpr;
      const clamped=Math.min(dist,maxD);
      const t=clamp(clamped/maxD,0,1);

      if(clamped>3*this.r.dpr){
        const inv=1/(dist||1);
        const dir={ x:dx*inv, y:dy*inv }; // dirección EXACTA del arrastre
        const impulse=lerp(CONFIG.shot.minImpulse, CONFIG.shot.maxImpulse, t);
        this.game.shootBall(dir,impulse);
      }

      this.aiming=false;
    }

    resetSelection(){
      this.aiming=false;
      this.ballSelected=false;
    }
  }

  class Game{
    constructor(canvas,shell){
      this.canvas=canvas;
      this.shell=shell;

      this.ui={
        scoreA:document.getElementById('scoreA'),
        scoreB:document.getElementById('scoreB'),
        turnText:document.getElementById('turnText'),
        turnPill:document.getElementById('turnPill'),
        goalBanner:document.getElementById('goalBanner'),
        dbg:document.getElementById('dbg'),
        btnUndo:document.getElementById('undo'),
        btnReset:document.getElementById('reset'),
        btnHelp:document.getElementById('help'),
      };

      this.scoreA=0; this.scoreB=0;
      this.turn = (Math.random()<0.5)?'A':'B'; // ✅ turno inicial aleatorio
      this.phase='ready'; // ready | sim | paused | gameover
      this.winner=null;

      this.ball=new Ball(CONFIG.world.w/2, CONFIG.world.h/2);
      this.pegs=[];
      this.buildFixedLayout();

      this.physics=new Physics(this);
      this.renderer=new Renderer(this, canvas, shell);
      this.input=new Input(this, canvas, this.renderer);

      this.undoSnap=null;

      this.goalBannerUntil=0;
      this.pauseUntil=0;
      this.simStartMs=0;

      this.acc=0;
      this.last=nowMs();

      this.bindUI();
      this.updateHUD();

      // Colocar bola en esquina del que saca
      this.placeBallForTurn();

      requestAnimationFrame(()=>this.loop());
    }

    bindUI(){
      this.ui.btnReset.addEventListener('click', ()=>this.reset());
      this.ui.btnUndo.addEventListener('click', ()=>this.undo());
      this.ui.btnHelp.addEventListener('click', ()=>document.getElementById('helpBack').classList.add('show'));
      document.getElementById('closeHelp').addEventListener('click', ()=>document.getElementById('helpBack').classList.remove('show'));
      document.getElementById('helpBack').addEventListener('click', (e)=>{
        if(e.target.id==='helpBack') document.getElementById('helpBack').classList.remove('show');
      });
    }

    // ✅ Disposición tipo la imagen (hardcode positions)
    buildFixedLayout(){
      this.pegs=[];

      const W=CONFIG.world.w, H=CONFIG.world.h;

      // Coordenadas aproximadas a la foto: 11 por lado
      // Team A (izquierda, azul)
      const A = [
        [90, H*0.50],     // portero
        [220, H*0.20],
        [240, H*0.38],
        [240, H*0.62],
        [220, H*0.80],
        [360, H*0.22],
        [380, H*0.40],
        [380, H*0.60],
        [360, H*0.78],
        [520, H*0.32],
        [520, H*0.68],
      ];

      // Team B (derecha, rojo)
      const B = [
        [W-90, H*0.50],   // portero
        [W-220, H*0.20],
        [W-240, H*0.38],
        [W-240, H*0.62],
        [W-220, H*0.80],
        [W-360, H*0.22],
        [W-380, H*0.40],
        [W-380, H*0.60],
        [W-360, H*0.78],
        [W-520, H*0.32],
        [W-520, H*0.68],
      ];

      for(let i=0;i<CONFIG.teams.count;i++){
        const p=A[i];
        this.pegs.push(new Peg(p[0],p[1],'A',`A${i}`));
      }
      for(let i=0;i<CONFIG.teams.count;i++){
        const p=B[i];
        this.pegs.push(new Peg(p[0],p[1],'B',`B${i}`));
      }

      // micro jitter para que no esté matemático
      for(const p of this.pegs){
        p.p.x += rand(-6,6);
        p.p.y += rand(-8,8);
      }
    }

    getActiveBodies(){ return [this.ball, ...this.pegs.filter(p=>p.active)]; }

    updateHUD(){
      this.ui.scoreA.textContent=String(this.scoreA);
      this.ui.scoreB.textContent=String(this.scoreB);
      this.ui.turnText.textContent=(this.turn==='A')?'Equipo A':'Equipo B';
      // A azul, B rojo
      this.ui.turnPill.style.background=(this.turn==='A')?'#4da3ff':'#ff6b6b';
      this.ui.btnUndo.disabled = !this.undoSnap || this.phase!=='ready';
    }

    canShootNow(){
      // Sólo se puede chutar si la bola está colocada y casi parada
      return this.phase==='ready' && this.ball.speed() < 0.5;
    }

    snapshot(){
      return {
        turn:this.turn,
        scoreA:this.scoreA, scoreB:this.scoreB,
        phase:this.phase, winner:this.winner,
        goalBannerUntil:this.goalBannerUntil,
        pauseUntil:this.pauseUntil,
        ball:{ p:{x:this.ball.p.x,y:this.ball.p.y}, v:{x:this.ball.v.x,y:this.ball.v.y}, active:this.ball.active },
        pegs:this.pegs.map(p=>({ id:p.id, team:p.team, active:p.active, p:{x:p.p.x,y:p.p.y}, v:{x:p.v.x,y:p.v.y} })),
      };
    }

    applySnapshot(s){
      this.turn=s.turn;
      this.scoreA=s.scoreA; this.scoreB=s.scoreB;
      this.phase=s.phase; this.winner=s.winner;
      this.goalBannerUntil=s.goalBannerUntil||0;
      this.pauseUntil=s.pauseUntil||0;

      this.ball.p.x=s.ball.p.x; this.ball.p.y=s.ball.p.y;
      this.ball.v.x=s.ball.v.x; this.ball.v.y=s.ball.v.y;
      this.ball.active=s.ball.active;

      const map=new Map(this.pegs.map(p=>[p.id,p]));
      for(const sp of s.pegs){
        const p=map.get(sp.id);
        if(!p) continue;
        p.active=sp.active;
        p.p.x=sp.p.x; p.p.y=sp.p.y;
        p.v.x=sp.v.x; p.v.y=sp.v.y;
      }

      this.input.resetSelection();
      this.updateHUD();
    }

    undo(){
      if(!this.undoSnap) return;
      if(this.phase!=='ready') return;
      this.applySnapshot(this.undoSnap);
      this.undoSnap=null;
      this.updateHUD();
    }

    reset(){
      this.scoreA=0; this.scoreB=0;
      this.turn = (Math.random()<0.5)?'A':'B';
      this.phase='ready';
      this.winner=null;

      this.ball.p.x=CONFIG.world.w/2; this.ball.p.y=CONFIG.world.h/2;
      this.ball.v.x=0; this.ball.v.y=0; this.ball.active=true;

      this.buildFixedLayout();
      this.undoSnap=null;
      this.goalBannerUntil=0;
      this.pauseUntil=0;

      this.input.resetSelection();

      this.placeBallForTurn();
      this.updateHUD();
    }

    // ✅ Saque desde esquina del campo del que tira
    placeBallForTurn(){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const margin = 52; // dentro del campo
      const topCorner = { y: margin };
      const botCorner = { y: H - margin };

      const chooseTop = Math.random() < 0.5;

      if(this.turn==='A'){
        this.ball.p.x = margin;
        this.ball.p.y = chooseTop ? topCorner.y : botCorner.y;
      }else{
        this.ball.p.x = W - margin;
        this.ball.p.y = chooseTop ? topCorner.y : botCorner.y;
      }

      this.ball.v.x=0; this.ball.v.y=0;
    }

    shootBall(dir, impulse){
      if(this.phase!=='ready') return;
      if(!this.canShootNow()) return;

      // Snapshot para undo justo antes del tiro
      this.undoSnap=this.snapshot();

      // Impulso a la bola
      this.ball.v.x += dir.x * (impulse / this.ball.mass);
      this.ball.v.y += dir.y * (impulse / this.ball.mass);

      this.phase='sim';
      this.simStartMs=nowMs();
      this.updateHUD();
    }

    allStopped(){
      for(const b of this.getActiveBodies()){
        if(b.speed()>CONFIG.physics.stopSpeed) return false;
      }
      return true;
    }

    checkGoal(){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const open=CONFIG.goal.opening;
      const yTop=(H-open)/2, yBot=yTop+open;
      const b=this.ball;

      const inMouth = (b.p.y>=yTop && b.p.y<=yBot);

      // Gol: la bola ha entrado completamente (centro +/- radio)
      if(inMouth && (b.p.x + b.r < 0)) return { scorer:'B', conceded:'A' };
      if(inMouth && (b.p.x - b.r > W)) return { scorer:'A', conceded:'B' };

      return null;
    }

    removeOnePeg(team){
      const candidates=this.pegs.filter(p=>p.active && p.team===team);
      if(!candidates.length) return;

      // Quitar uno de manera "natural": el más cercano a su portería (como perder un jugador atrás)
      const targetX = (team==='A') ? 0 : CONFIG.world.w;
      let best=candidates[0], bestScore=Infinity;
      for(const p of candidates){
        const score = Math.abs(p.p.x - targetX) * 1.0 + Math.abs(p.p.y - CONFIG.world.h/2) * 0.15;
        if(score < bestScore){ bestScore=score; best=p; }
      }
      best.active=false;
      best.v.x=best.v.y=0;
    }

    applyGoal(g){
      if(this.phase==='gameover') return;

      if(g.scorer==='A') this.scoreA++; else this.scoreB++;

      // ✅ Al meter gol, se quita un palito del equipo que encaja (rival del que marca)
      this.removeOnePeg(g.conceded);

      // Efecto GOOL
      this.goalBannerUntil=nowMs()+CONFIG.effects.goalBannerMs;
      document.getElementById('goalBanner').classList.add('show');

      // Victoria
      if(this.scoreA>=11 || this.scoreB>=11){
        this.phase='gameover';
        this.winner=(this.scoreA>=11)?'A':'B';
      }else{
        // Pausa breve y siguiente turno
        this.pauseUntil=nowMs()+CONFIG.effects.goalPauseMs;
        this.phase='paused';
      }

      // Parar todo
      for(const b of this.getActiveBodies()){ b.v.x=0; b.v.y=0; }

      // Turno cambia y coloca bola en su esquina (nuevo saque)
      this.turn = (this.turn==='A')?'B':'A';
      this.placeBallForTurn();

      this.input.resetSelection();
      this.updateHUD();
    }

    drawGameOverOverlay(){
      const ctx=this.renderer.ctx;
      const w=this.renderer.w, h=this.renderer.h;
      const dpr=this.renderer.dpr;
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.35)';
      ctx.fillRect(0,0,w,h);

      const text=(this.winner==='A')?'¡GANA EQUIPO A!':'¡GANA EQUIPO B!';
      ctx.font=`1000 ${Math.floor(54*dpr)}px system-ui`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(255,255,255,.92)';
      ctx.shadowColor='rgba(0,0,0,.45)';
      ctx.shadowBlur=18*dpr;
      ctx.fillText(text,w/2,h/2-22*dpr);
      ctx.shadowBlur=0;

      ctx.font=`800 ${Math.floor(16*dpr)}px system-ui`;
      ctx.fillStyle='rgba(234,240,255,.85)';
      ctx.fillText('Pulsa “Reiniciar partido” para jugar otra vez.',w/2,h/2+28*dpr);

      ctx.restore();
    }

    loop(){
      const t=nowMs();
      const dtFrame=Math.min((t-this.last)/1000, 0.05);
      this.last=t;
      this.acc += dtFrame;

      // Hide GOOL banner
      if(t>=this.goalBannerUntil){
        document.getElementById('goalBanner').classList.remove('show');
      }

      // Pause after goal
      if(this.phase==='paused' && t>=this.pauseUntil){
        this.phase='ready';
        this.updateHUD();
      }

      if(this.phase==='sim'){
        const fixed=CONFIG.physics.dt;
        let steps=0;
        while(this.acc>=fixed && steps<CONFIG.physics.maxSubStepsPerFrame){
          this.physics.step(fixed);
          this.acc -= fixed;
          steps++;
        }

        const goal=this.checkGoal();
        if(goal){
          this.applyGoal(goal);
        }else{
          const elapsed=(t-this.simStartMs)/1000;
          if(this.allStopped() || elapsed>=CONFIG.physics.maxSimSeconds){
            for(const b of this.getActiveBodies()){ b.v.x=0; b.v.y=0; }
            this.phase='ready';

            // ✅ fin del turno: cambia el turno y recoloca bola en esquina del que saca
            this.turn=(this.turn==='A')?'B':'A';
            this.placeBallForTurn();

            this.input.resetSelection();
            this.updateHUD();
          }
        }
      }

      // Render
      this.renderer.draw();

      if(this.phase==='gameover'){
        this.drawGameOverOverlay();
      }

      requestAnimationFrame(()=>this.loop());
    }
  }

  // Init
  const canvas=document.getElementById('c');
  const shell=document.getElementById('shell');
  const game=new Game(canvas,shell);

  // Help modal close on ESC
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Escape') document.getElementById('helpBack').classList.remove('show');
  });

})();
</script>

<!--
============================================================
CÓMO JUGAR
============================================================
- Turnos alternos A/B.
- Cada turno es un SAQUE: la bola se coloca en una esquina del campo del equipo que tira.
- Para chutar: selecciona la bola y arrastra en la dirección exacta del tiro.
  La potencia depende de la distancia del arrastre (limitada).
- Los palitos de ambos equipos estorban (incluido tu propio equipo).
- Gol: la bola entra completamente en la portería rival.
- Al gol: se quita 1 palito del equipo que encaja y se deja apoyado en el borde (visible).
- Gana quien llegue a 11.

============================================================
PARÁMETROS RECOMENDADOS PARA AJUSTAR (CONFIG)
============================================================
- CONFIG.shot.maxImpulse / maxDrag: fuerza y recorrido del tiro.
- CONFIG.ball.damp / CONFIG.peg.damp: fricción (más bajo = se para antes).
- CONFIG.physics.solverIterations: estabilidad colisiones.
- CONFIG.goal.opening: tamaño de la boca.
- CONFIG.render.removed.scale/alpha: tamaño y aspecto de palitos retirados.
-->
</body>
</html>
