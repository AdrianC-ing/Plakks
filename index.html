<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PLAKKS-like Flick Soccer (Static Pegs)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#eaf0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .wrap{height:100%;display:flex;flex-direction:column;padding:12px;gap:10px;max-width:1200px;margin:0 auto;}
    .top{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .title{font-weight:900;letter-spacing:.2px;font-size:15px;display:flex;gap:10px;align-items:center}
    .badge{font-weight:800;font-size:12px;padding:3px 8px;border-radius:999px;background:rgba(125,211,252,.14);border:1px solid rgba(125,211,252,.35);color:#c9f2ff}
    .sub{font-size:12px;opacity:.75;margin-top:2px}
    .hud{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    .score{
      display:flex;align-items:center;gap:10px;padding:8px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);
      min-width:190px;justify-content:space-between
    }
    .teamTag{display:flex;align-items:center;gap:8px;font-weight:900;font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%;box-shadow:0 0 0 3px rgba(255,255,255,.06)}
    .dotA{background:#4da3ff}
    .dotB{background:#ff6b6b}
    .scoreNum{font-weight:1000;font-size:20px;letter-spacing:.6px}
    .turn{
      padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);font-weight:900;font-size:12px;display:flex;gap:8px;align-items:center
    }
    .pill{width:10px;height:10px;border-radius:50%;box-shadow:0 0 0 3px rgba(255,255,255,.06)}
    .btnRow{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    button{
      cursor:pointer;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);color:#eaf0ff;
      padding:8px 10px;border-radius:12px;font-weight:800;font-size:12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 10px 20px rgba(0,0,0,.18);
    }
    button:active{transform:translateY(1px)}
    button.secondary{border-color:rgba(167,139,250,.35);background:rgba(167,139,250,.12)}
    button.danger{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.12)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .shell{
      position:relative;flex:1;border-radius:16px;border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);overflow:hidden;min-height:520px;
      box-shadow: 0 18px 42px rgba(0,0,0,.32);
    }
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:#091022}
    .note{
      position:absolute;left:12px;bottom:10px;z-index:5;
      padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.10);font-size:12px;line-height:1.35;max-width:min(720px,calc(100% - 24px));
      color:rgba(234,240,255,.8)
    }
    .note b{color:#fff}

    .goalBanner{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;
      opacity:0;transition:opacity .18s ease;z-index:8;
    }
    .goalBanner.show{opacity:1}
    .goalText{
      font-weight:1000;letter-spacing:2px;font-size:clamp(44px,7vw,92px);
      padding:10px 22px;border-radius:20px;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.15);
      box-shadow:0 24px 80px rgba(0,0,0,.45);text-shadow:0 16px 30px rgba(0,0,0,.45);
      transform:translateY(10px) scale(.98);transition:transform .18s ease;
    }
    .goalBanner.show .goalText{transform:translateY(0) scale(1)}

    .modalBack{
      position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:16px;z-index:50;
    }
    .modalBack.show{display:flex}
    .modal{
      width:min(760px,100%);border-radius:16px;border:1px solid rgba(255,255,255,.12);
      background:rgba(15,26,47,.96);box-shadow:0 30px 100px rgba(0,0,0,.55);
      padding:16px 16px 12px;
    }
    .modal h2{margin:0 0 8px;font-size:16px}
    .modal p,.modal li{font-size:13px;line-height:1.45;color:rgba(234,240,255,.85)}
    .modal ul{margin:8px 0 0 18px}
    .modal .top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px;padding:0;border:0;background:none;box-shadow:none}

    .overlay{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:20;
      background:rgba(0,0,0,.45);
      backdrop-filter: blur(4px);
    }
    .overlay.show{display:flex}
    .panel{
      width:min(520px,calc(100% - 24px));
      border-radius:16px;border:1px solid rgba(255,255,255,.14);
      background:rgba(15,26,47,.94);
      box-shadow:0 26px 90px rgba(0,0,0,.55);
      padding:14px;
    }
    .panel h3{margin:0 0 6px;font-size:15px}
    .panel p{margin:0 0 12px;font-size:13px;line-height:1.4;color:rgba(234,240,255,.82)}
    .choiceRow{display:flex;gap:10px;flex-wrap:wrap}
    .choiceRow button{flex:1;min-width:150px}
    .hint{margin-top:10px;font-size:12px;color:rgba(234,240,255,.70)}
    @media(max-width:720px){
      .top{flex-direction:column;align-items:stretch}
      .btnRow button{flex:1}
      .shell{min-height:62vh}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <div class="title">PLAKKS-like Flick Soccer <span class="badge">pegs fijos</span></div>
      <div class="sub">Tirachinas: cargas hacia atrás y la bola sale hacia delante · Tras gol: el que encaja elige esquina</div>
    </div>
    <div class="hud">
      <div class="score" aria-label="Marcador">
        <div class="teamTag"><span class="dot dotA"></span>Equipo A</div>
        <div class="scoreNum"><span id="scoreA">0</span> – <span id="scoreB">0</span></div>
        <div class="teamTag">Equipo B<span class="dot dotB"></span></div>
      </div>
      <div class="turn" aria-label="Turno">
        <span>Turno:</span><span class="pill" id="turnPill"></span><span id="turnText">Equipo A</span>
      </div>
      <div class="btnRow">
        <button id="undo" class="secondary">Deshacer último tiro</button>
        <button id="reset" class="danger">Reiniciar partido</button>
        <button id="help">Ayuda</button>
      </div>
    </div>
  </div>

  <div class="shell" id="shell">
    <canvas id="c"></canvas>
    <div class="goalBanner" id="goalBanner"><div class="goalText">GOOOL</div></div>

    <div class="overlay" id="cornerOverlay">
      <div class="panel">
        <h3 id="cornerTitle">Elige esquina para sacar</h3>
        <p id="cornerDesc">El equipo que recibió el gol saca ahora. Elige una de tus dos esquinas.</p>
        <div class="choiceRow">
          <button id="cornerTop" class="secondary">Esquina superior</button>
          <button id="cornerBottom" class="secondary">Esquina inferior</button>
        </div>
        <div class="hint">Después del saque, la bola se juega desde donde se quede.</div>
      </div>
    </div>

    <div class="note">
      <b>Cómo chutar:</b> click/toca la <b>bola</b> → arrastra <b>hacia atrás</b> para cargar → suelta (sale hacia delante).<br/>
      <span style="opacity:.9">Potencia progresiva. Tras gol: el que encaja elige esquina.</span>
    </div>
  </div>
</div>

<div class="modalBack" id="helpBack" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="modal">
    <div class="top">
      <h2 id="helpTitle">Ayuda · Reglas y controles</h2>
      <button id="closeHelp">Cerrar</button>
    </div>
    <ul>
      <li><b>Turnos:</b> alternan A/B. En tu turno haces <b>un</b> chute con la <b>bola</b>.</li>
      <li><b>Control:</b> estilo <b>tirachinas</b>: arrastra hacia atrás para cargar; la bola sale hacia delante.</li>
      <li><b>Palitos:</b> fijos. Solo se quitan cuando hay gol.</li>
      <li><b>Saque inicial:</b> esquina del equipo inicial (aleatoria).</li>
      <li><b>Tras gol:</b> saca el equipo que encaja y elige esquina.</li>
      <li><b>Si no hay gol:</b> la bola se juega desde donde quedó.</li>
    </ul>
  </div>
</div>

<script>
(() => {
  /* =========================
     CONFIG
  ========================= */
  const CONFIG = {
    world: { w: 1200, h: 720 },
    goal: { opening: 220, depth: 46, postRadius: 10 },

    ball: { r: 16, mass: 1.0, restitution: 0.90, damp: 0.994, maxSpeed: 1800 },
    peg:  { r: 24, restitution: 0.55 }, // pegs fijos

    teams: { count: 11 },

    // Potencia progresiva (suave al principio)
    shot: {
      maxDrag: 240,
      minSpeed: 140,
      maxSpeed: 980,
      responseCurve: 1.8,
      aimLineW: 3
    },

    physics: {
      dt: 1/120,
      maxSubStepsPerFrame: 10,
      solverIterations: 2,
      wallRestitution: 0.86,
      stopSpeed: 14,
      maxSimSeconds: 4.0,
      penetrationSlop: 0.02,
      penetrationPercent: 0.92,
    },

    render: {
      pitchMargin: 34,
      pitchCornerR: 38,
      grassNoise: 0.06,
      shadowOffset: { x: 10, y: 14 },
      shadowBlur: 16,
      vignette: true,
      removed: { scale: 0.72, alpha: 0.68, pad: 10, gap: 8 },
    },

    effects: { goalBannerMs: 850, goalPauseMs: 520 },
    cornerMargin: 52,
  };

  /* =========================
     Utils
  ========================= */
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const hypot = (x,y)=>Math.hypot(x,y);
  const nowMs = ()=>performance.now();
  const rand = (a,b)=>a+Math.random()*(b-a);

  class Vec2{
    constructor(x=0,y=0){this.x=x;this.y=y;}
    mag(){return Math.hypot(this.x,this.y);}
    mul(s){this.x*=s;this.y*=s;return this;}
    dot(v){return this.x*v.x+this.y*v.y;}
    static sub(a,b){return new Vec2(a.x-b.x,a.y-b.y);}
    static mul(a,s){return new Vec2(a.x*s,a.y*s);}
  }

  class Ball{
    constructor(x,y){
      this.p=new Vec2(x,y);
      this.v=new Vec2(0,0);
      this.r=CONFIG.ball.r;
      this.mass=CONFIG.ball.mass;
      this.restitution=CONFIG.ball.restitution;
      this.damp=CONFIG.ball.damp;
      this.maxSpeed=CONFIG.ball.maxSpeed;
    }
    speed(){return this.v.mag();}
  }

  class Peg{
    constructor(x,y,team,id){
      this.p=new Vec2(x,y);
      this.r=CONFIG.peg.r;
      this.team=team;
      this.id=id;
      this.active=true;
    }
  }

  class Physics{
    constructor(game){this.game=game;}
    step(dt){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const b=this.game.ball;

      b.p.x += b.v.x*dt;
      b.p.y += b.v.y*dt;

      b.v.mul(b.damp);

      const s=b.speed();
      if(s>b.maxSpeed){
        const k=b.maxSpeed/(s+1e-9);
        b.v.mul(k);
      }

      const e=CONFIG.physics.wallRestitution;

      if(b.p.x-b.r<0){ b.p.x=b.r; b.v.x=Math.abs(b.v.x)*e; }
      if(b.p.x+b.r>W){ b.p.x=W-b.r; b.v.x=-Math.abs(b.v.x)*e; }
      if(b.p.y-b.r<0){ b.p.y=b.r; b.v.y=Math.abs(b.v.y)*e; }
      if(b.p.y+b.r>H){ b.p.y=H-b.r; b.v.y=-Math.abs(b.v.y)*e; }

      for(let it=0; it<CONFIG.physics.solverIterations; it++){
        for(const p of this.game.pegs){
          if(!p.active) continue;
          this.resolveBallPeg(b,p);
        }
      }
    }

    resolveBallPeg(ball, peg){
      const n=Vec2.sub(ball.p, peg.p);
      let dist=n.mag();
      const r=ball.r+peg.r;
      if(dist<=0) dist=0.0001;

      if(dist<r){
        const penetration=r-dist;
        const normal=n.mul(1/dist);

        const slop=CONFIG.physics.penetrationSlop;
        const percent=CONFIG.physics.penetrationPercent;
        const corr=Math.max(penetration-slop,0)*percent;

        ball.p.x += normal.x*corr;
        ball.p.y += normal.y*corr;

        const v = ball.v;
        const velAlong = v.dot(normal);

        if(velAlong<0){
          const e = Math.min(ball.restitution, CONFIG.peg.restitution);
          ball.v.x = v.x - (1+e)*velAlong*normal.x;
          ball.v.y = v.y - (1+e)*velAlong*normal.y;

          const tangent=new Vec2(v.x-velAlong*normal.x, v.y-velAlong*normal.y);
          const tmag=tangent.mag();
          if(tmag>1e-6){
            tangent.mul(1/tmag);
            ball.v.x -= tangent.x*3.0;
            ball.v.y -= tangent.y*3.0;
          }
        }
      }
    }
  }

  class Renderer{
    constructor(game,canvas,shell){
      this.game=game; this.canvas=canvas; this.shell=shell;
      this.ctx=canvas.getContext('2d');

      this.noise=document.createElement('canvas');
      this.noise.width=256; this.noise.height=256;
      this.noiseCtx=this.noise.getContext('2d');
      this.buildNoise();

      this.scale=1; this.ox=0; this.oy=0; this.w=0; this.h=0; this.dpr=1;
    }

    buildNoise(){
      const img=this.noiseCtx.createImageData(256,256);
      for(let i=0;i<img.data.length;i+=4){
        const n=(Math.random()*2-1)*255;
        img.data[i]=0;
        img.data[i+1]=120+n*0.08;
        img.data[i+2]=0;
        img.data[i+3]=255;
      }
      this.noiseCtx.putImageData(img,0,0);
    }

    resize(){
      const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
      const r=this.shell.getBoundingClientRect();
      const cssW=Math.max(300, r.width||900);
      const cssH=Math.max(300, r.height||540);
      const w=Math.floor(cssW*dpr);
      const h=Math.floor(cssH*dpr);
      if(this.canvas.width!==w||this.canvas.height!==h){this.canvas.width=w;this.canvas.height=h;}

      const pad=CONFIG.render.pitchMargin*dpr;
      const sx=(w-pad*2)/CONFIG.world.w;
      const sy=(h-pad*2)/CONFIG.world.h;
      const scale=Math.max(0.0001, Math.min(sx,sy));

      this.dpr=dpr; this.w=w; this.h=h; this.scale=scale;
      this.ox=(w-CONFIG.world.w*scale)*0.5;
      this.oy=(h-CONFIG.world.h*scale)*0.5;
    }

    w2s(p){ return { x:this.ox+p.x*this.scale, y:this.oy+p.y*this.scale }; }
    s2w(p){ return { x:(p.x-this.ox)/this.scale, y:(p.y-this.oy)/this.scale }; }

    roundRect(x,y,w,h,r){
      const ctx=this.ctx;
      const rr=Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    drawPitch(){
      const ctx=this.ctx;
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const x0=this.ox, y0=this.oy, s=this.scale;

      const g=ctx.createLinearGradient(x0,y0,x0+W*s,y0+H*s);
      g.addColorStop(0,'#0f6b3c');
      g.addColorStop(0.5,'#0e5f37');
      g.addColorStop(1,'#0b4a2c');

      const r=CONFIG.render.pitchCornerR*this.dpr;
      ctx.save();
      ctx.fillStyle=g;
      this.roundRect(x0,y0,W*s,H*s,r);
      ctx.fill();

      ctx.globalAlpha=0.13;
      for(let i=0;i<10;i++){
        const yy=y0+(H*s)*(i/10);
        ctx.fillStyle=(i%2===0)?'#0b4f2f':'#0f7343';
        ctx.fillRect(x0,yy,W*s,(H*s)/10);
      }
      ctx.globalAlpha=1;

      ctx.globalAlpha=CONFIG.render.grassNoise;
      ctx.drawImage(this.noise,x0,y0,W*s,H*s);
      ctx.globalAlpha=1;

      ctx.lineWidth=3*this.dpr;
      ctx.strokeStyle='rgba(245,255,245,.85)';
      this.roundRect(x0+2*this.dpr,y0+2*this.dpr,W*s-4*this.dpr,H*s-4*this.dpr,Math.max(2,r-6*this.dpr));
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x0+(W*s)/2, y0+2*this.dpr);
      ctx.lineTo(x0+(W*s)/2, y0+H*s-2*this.dpr);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x0+(W*s)/2,y0+(H*s)/2,110*s,0,Math.PI*2);
      ctx.stroke();

      ctx.fillStyle='rgba(245,255,245,.95)';
      ctx.beginPath();
      ctx.arc(x0+(W*s)/2,y0+(H*s)/2,5*this.dpr,0,Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    drawGoals(){
      const ctx=this.ctx;
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const open=CONFIG.goal.opening;
      const depth=CONFIG.goal.depth;
      const postR=CONFIG.goal.postRadius;
      const s=this.scale;

      const drawOne = (side) => {
        const dir = (side==='left')? 1 : -1;
        const cx  = (side==='left')? 0 : W;
        const yTop=(H-open)/2;
        const yBot=yTop+open;

        const xEdge=this.ox+cx*s;
        const yT=this.oy+yTop*s;
        const yB=this.oy+yBot*s;
        const d=depth*s;

        ctx.save();
        ctx.lineWidth=2.5*this.dpr;
        ctx.strokeStyle='rgba(255,255,255,.32)';
        ctx.beginPath();
        ctx.moveTo(xEdge+dir*d, yT+d*0.18);
        ctx.lineTo(xEdge+dir*d, yB-d*0.18);
        ctx.stroke();

        ctx.globalAlpha=0.22;
        ctx.strokeStyle='rgba(255,255,255,.75)';
        for(let i=0;i<10;i++){
          const t=i/9;
          const yy=lerp(yT+6*this.dpr,yB-6*this.dpr,t);
          ctx.beginPath();
          ctx.moveTo(xEdge,yy);
          ctx.lineTo(xEdge+dir*d,yy+d*0.10*dir);
          ctx.stroke();
        }
        ctx.globalAlpha=1;

        const postX=xEdge+dir*(postR*s*0.15);
        const rr=postR*s;

        const drawPost = (x,y) => {
          const grd=ctx.createRadialGradient(x-rr*0.4,y-rr*0.4,rr*0.3,x,y,rr*1.05);
          grd.addColorStop(0,'rgba(255,255,255,.95)');
          grd.addColorStop(0.6,'rgba(255,255,255,.55)');
          grd.addColorStop(1,'rgba(255,255,255,.25)');
          ctx.fillStyle=grd;
          ctx.beginPath(); ctx.arc(x,y,rr,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle='rgba(0,0,0,.22)';
          ctx.lineWidth=1.2*this.dpr;
          ctx.stroke();
        };

        drawPost(postX,yT);
        drawPost(postX,yB);

        ctx.lineWidth=6*this.dpr;
        ctx.strokeStyle='rgba(255,255,255,.65)';
        ctx.beginPath();
        ctx.moveTo(postX,yT);
        ctx.lineTo(postX,yB);
        ctx.stroke();

        ctx.restore();
      };

      drawOne('left');
      drawOne('right');
    }

    drawShadowAt(x,y,r,alpha=0.35){
      const ctx=this.ctx;
      const off=CONFIG.render.shadowOffset;
      const sx=x+off.x*this.dpr;
      const sy=y+off.y*this.dpr;
      ctx.save();
      ctx.globalAlpha=alpha;
      ctx.fillStyle='rgba(0,0,0,.55)';
      ctx.shadowColor='rgba(0,0,0,.55)';
      ctx.shadowBlur=CONFIG.render.shadowBlur*this.dpr;
      ctx.beginPath();
      ctx.ellipse(sx,sy,r*1.05,r*0.78,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    drawPegScreen(x,y,rScreen,team,dimmed=false,alpha=1){
      const ctx=this.ctx;
      const base=(team==='A')?{a:'#4da3ff',b:'#124fae'}:{a:'#ff6b6b',b:'#b81f3d'};

      ctx.save();
      ctx.globalAlpha = alpha;

      const g=ctx.createRadialGradient(x-rScreen*0.35,y-rScreen*0.25,rScreen*0.2,x,y,rScreen*1.15);
      g.addColorStop(0,'rgba(255,255,255,.55)');
      g.addColorStop(0.18,base.a);
      g.addColorStop(1,base.b);

      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(x,y,rScreen,0,Math.PI*2); ctx.fill();

      ctx.globalAlpha = alpha * (dimmed ? 0.40 : 0.55);
      const hg=ctx.createLinearGradient(x-rScreen*0.7,y-rScreen*0.2,x+rScreen*0.7,y+rScreen*0.2);
      hg.addColorStop(0,'rgba(255,255,255,.0)');
      hg.addColorStop(0.38,'rgba(255,255,255,.42)');
      hg.addColorStop(0.62,'rgba(255,255,255,.12)');
      hg.addColorStop(1,'rgba(255,255,255,.0)');
      ctx.fillStyle=hg;
      ctx.beginPath();
      ctx.ellipse(x-rScreen*0.1,y-rScreen*0.1,rScreen*0.9,rScreen*0.55,-0.55,0,Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = alpha;
      ctx.strokeStyle='rgba(0,0,0,.22)';
      ctx.lineWidth=1.2*this.dpr;
      ctx.stroke();

      if(dimmed){
        ctx.globalAlpha = alpha * 0.25;
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        ctx.beginPath(); ctx.arc(x,y,rScreen,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = alpha;
      }

      ctx.restore();
    }

    drawPeg(peg){
      const p=this.w2s(peg.p);
      const r=peg.r*this.scale;
      this.drawShadowAt(p.x,p.y,r,0.34);
      this.drawPegScreen(p.x,p.y,r,peg.team,false,1);
    }

    drawBall(ball, selected){
      const ctx=this.ctx;
      const p=this.w2s(ball.p);
      const r=ball.r*this.scale;

      this.drawShadowAt(p.x,p.y,r,0.40);

      ctx.save();
      const g=ctx.createRadialGradient(p.x-r*0.35,p.y-r*0.35,r*0.35,p.x,p.y,r*1.15);
      g.addColorStop(0,'rgba(255,255,255,.98)');
      g.addColorStop(0.35,'rgba(255,255,255,.92)');
      g.addColorStop(0.7,'rgba(220,230,255,.88)');
      g.addColorStop(1,'rgba(140,160,190,.85)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.18)';
      ctx.lineWidth=1.3*this.dpr;
      ctx.stroke();

      ctx.globalAlpha=0.55;
      ctx.fillStyle='rgba(255,255,255,.85)';
      ctx.beginPath();
      ctx.ellipse(p.x-r*0.25,p.y-r*0.35,r*0.35,r*0.25,-0.6,0,Math.PI*2);
      ctx.fill();

      if(selected){
        ctx.globalAlpha=1;
        ctx.strokeStyle='rgba(125,211,252,.95)';
        ctx.lineWidth=3*this.dpr;
        ctx.beginPath();
        ctx.arc(p.x,p.y,r+4*this.dpr,0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }

    // Flecha se muestra hacia donde arrastras (hacia atrás). La bola sale en dirección opuesta.
    drawAim(input){
      if(!input.aiming || !input.ballSelected) return;
      const ctx=this.ctx;
      const ball=this.game.ball;
      const bp=this.w2s(ball.p);
      const m=input.mouse;

      const dx=m.x-bp.x, dy=m.y-bp.y;
      const dist=Math.hypot(dx,dy);

      const maxD=CONFIG.shot.maxDrag*this.dpr;
      const clamped=Math.min(dist,maxD);
      const t=clamp(clamped/maxD,0,1);

      ctx.save();
      ctx.lineWidth=CONFIG.shot.aimLineW*this.dpr;
      ctx.lineCap='round';
      ctx.strokeStyle=`rgba(125,211,252,${0.20+0.65*t})`;
      ctx.shadowColor='rgba(0,0,0,.35)';
      ctx.shadowBlur=10*this.dpr;

      const k=(dist>1e-6)?(clamped/dist):0;
      const ex=bp.x+dx*k, ey=bp.y+dy*k;

      ctx.beginPath();
      ctx.moveTo(bp.x,bp.y);
      ctx.lineTo(ex,ey);
      ctx.stroke();

      const ang=Math.atan2(dy,dx);
      const ah=10*this.dpr;
      ctx.beginPath();
      ctx.moveTo(ex,ey);
      ctx.lineTo(ex-Math.cos(ang-0.55)*ah, ey-Math.sin(ang-0.55)*ah);
      ctx.lineTo(ex-Math.cos(ang+0.55)*ah, ey-Math.sin(ang+0.55)*ah);
      ctx.closePath();
      ctx.fillStyle=`rgba(125,211,252,${0.25+0.60*t})`;
      ctx.fill();

      const bw=190*this.dpr, bh=10*this.dpr;
      const bx=this.ox+14*this.dpr, by=this.oy+(CONFIG.world.h*this.scale)-20*this.dpr;
      ctx.shadowBlur=0;
      ctx.fillStyle='rgba(0,0,0,.25)';
      this.roundRect(bx,by,bw,bh,6*this.dpr); ctx.fill();

      const pw=bw*t;
      const pg=ctx.createLinearGradient(bx,by,bx+bw,by);
      pg.addColorStop(0,'rgba(52,211,153,.9)');
      pg.addColorStop(0.55,'rgba(125,211,252,.9)');
      pg.addColorStop(1,'rgba(251,113,133,.9)');
      ctx.fillStyle=pg;
      this.roundRect(bx,by,pw,bh,6*this.dpr); ctx.fill();

      ctx.restore();
    }

    drawRemovedOnBorders(){
      const remCfg=CONFIG.render.removed;
      const pad=remCfg.pad*this.dpr;
      const gap=remCfg.gap*this.dpr;

      const leftEdge = this.ox;
      const rightEdge = this.ox + CONFIG.world.w*this.scale;

      const listA = this.game.pegs.filter(p=>!p.active && p.team==='A');
      const listB = this.game.pegs.filter(p=>!p.active && p.team==='B');

      const rNormal = CONFIG.peg.r*this.scale;
      const r = Math.max(6*this.dpr, rNormal*remCfg.scale);
      const step = (2*r + gap);

      const xA = Math.max(pad + r, leftEdge - (r + 10*this.dpr));
      const xB = Math.min(this.w - (pad + r), rightEdge + (r + 10*this.dpr));
      const startY = pad + 30*this.dpr;

      const drawStack = (team, list, x) => {
        for(let i=0;i<list.length;i++){
          const y = startY + i*step;
          if(y + r > this.h - pad) break;
          this.drawShadowAt(x,y,r,0.18);
          this.drawPegScreen(x,y,r,team,true,remCfg.alpha);
        }
      };

      drawStack('A', listA, xA);
      drawStack('B', listB, xB);
    }

    drawVignette(){
      if(!CONFIG.render.vignette) return;
      const ctx=this.ctx;
      const w=this.w, h=this.h;
      const g=ctx.createRadialGradient(w*0.5,h*0.5,Math.min(w,h)*0.25,w*0.5,h*0.5,Math.max(w,h)*0.65);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,'rgba(0,0,0,.35)');
      ctx.save();
      ctx.fillStyle=g;
      ctx.fillRect(0,0,w,h);
      ctx.restore();
    }

    draw(){
      this.resize();
      const ctx=this.ctx;
      ctx.clearRect(0,0,this.w,this.h);

      this.drawPitch();
      this.drawGoals();

      for(const p of this.game.pegs){
        if(p.active) this.drawPeg(p);
      }

      this.drawBall(this.game.ball, this.game.input.ballSelected);

      this.drawRemovedOnBorders();
      this.drawAim(this.game.input);
      this.drawVignette();
    }
  }

  class Input{
    constructor(game,canvas,renderer){
      this.game=game; this.canvas=canvas; this.r=renderer;
      this.mouse={x:0,y:0};
      this.pointerDown=false;
      this.aiming=false;
      this.ballSelected=false;

      canvas.addEventListener('pointerdown', (e)=>this.onDown(e));
      window.addEventListener('pointermove', (e)=>this.onMove(e), {passive:true});
      window.addEventListener('pointerup', (e)=>this.onUp(e));
      canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
      canvas.addEventListener('touchmove', (e)=>e.preventDefault(), {passive:false});
    }

    pos(e){
      const rect=this.canvas.getBoundingClientRect();
      const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
      return { x:(e.clientX-rect.left)*dpr, y:(e.clientY-rect.top)*dpr };
    }

    onDown(e){
      if(this.game.phase!=='ready') return;
      if(!this.game.canShootNow()) return;

      this.pointerDown=true;
      this.mouse=this.pos(e);

      const wpos=this.r.s2w(this.mouse);
      const b=this.game.ball;
      const d=hypot(wpos.x-b.p.x,wpos.y-b.p.y);

      if(d<=b.r*1.25){
        this.ballSelected=true;
        this.aiming=true;
      }else{
        this.ballSelected=false;
        this.aiming=false;
      }
    }

    onMove(e){ this.mouse=this.pos(e); }

    onUp(e){
      if(!this.pointerDown) return;
      this.pointerDown=false;

      if(!this.aiming || !this.ballSelected) { this.aiming=false; return; }
      if(this.game.phase!=='ready') { this.aiming=false; return; }
      if(!this.game.canShootNow()) { this.aiming=false; return; }

      const ball=this.game.ball;
      const bp=this.r.w2s(ball.p);

      const dx=this.mouse.x-bp.x, dy=this.mouse.y-bp.y; // arrastre hacia atrás
      const dist=Math.hypot(dx,dy);

      const maxD=CONFIG.shot.maxDrag*this.r.dpr;
      const clamped=Math.min(dist,maxD);
      const tRaw=clamp(clamped/maxD,0,1);

      const t = Math.pow(tRaw, CONFIG.shot.responseCurve);

      if(clamped>3*this.r.dpr){
        const inv=1/(dist||1);

        // ✅ TIRACHINAS: sale en dirección opuesta al arrastre
        const dir={ x:-dx*inv, y:-dy*inv };

        const targetSpeed = lerp(CONFIG.shot.minSpeed, CONFIG.shot.maxSpeed, t);

        ball.v.x = dir.x * targetSpeed;
        ball.v.y = dir.y * targetSpeed;

        this.game.onShot();
      }

      this.aiming=false;
    }

    resetSelection(){ this.aiming=false; this.ballSelected=false; }
  }

  class Game{
    constructor(canvas,shell){
      this.canvas=canvas; this.shell=shell;

      this.ui={
        scoreA:document.getElementById('scoreA'),
        scoreB:document.getElementById('scoreB'),
        turnText:document.getElementById('turnText'),
        turnPill:document.getElementById('turnPill'),
        btnUndo:document.getElementById('undo'),
        btnReset:document.getElementById('reset'),
        btnHelp:document.getElementById('help'),
        goalBanner:document.getElementById('goalBanner'),
        cornerOverlay:document.getElementById('cornerOverlay'),
        cornerTitle:document.getElementById('cornerTitle'),
        cornerDesc:document.getElementById('cornerDesc'),
        cornerTop:document.getElementById('cornerTop'),
        cornerBottom:document.getElementById('cornerBottom'),
      };

      this.scoreA=0; this.scoreB=0;
      this.turn = (Math.random()<0.5)?'A':'B';
      this.phase='ready'; // ready | sim | paused | waitingCorner | gameover
      this.winner=null;

      this.ball=new Ball(CONFIG.world.w/2, CONFIG.world.h/2);
      this.pegs=[];
      this.buildFixedLayout();

      this.physics=new Physics(this);
      this.renderer=new Renderer(this, canvas, shell);
      this.input=new Input(this, canvas, this.renderer);

      this.undoSnap=null;
      this.goalBannerUntil=0;
      this.pauseUntil=0;
      this.simStartMs=0;
      this.pendingCornerTeam=null;

      this.acc=0;
      this.last=nowMs();

      this.bindUI();
      this.updateHUD();

      // saque inicial aleatorio (esquina arriba/abajo)
      this.placeBallAtCornerForTeam(this.turn, Math.random()<0.5 ? 'top' : 'bottom');

      requestAnimationFrame(()=>this.loop());
    }

    bindUI(){
      this.ui.btnReset.addEventListener('click', ()=>this.reset());
      this.ui.btnUndo.addEventListener('click', ()=>this.undo());
      this.ui.btnHelp.addEventListener('click', ()=>document.getElementById('helpBack').classList.add('show'));
      document.getElementById('closeHelp').addEventListener('click', ()=>document.getElementById('helpBack').classList.remove('show'));
      document.getElementById('helpBack').addEventListener('click', (e)=>{
        if(e.target.id==='helpBack') document.getElementById('helpBack').classList.remove('show');
      });

      this.ui.cornerTop.addEventListener('click', ()=>this.chooseCorner('top'));
      this.ui.cornerBottom.addEventListener('click', ()=>this.chooseCorner('bottom'));
    }

    buildFixedLayout(){
      this.pegs=[];
      const W=CONFIG.world.w, H=CONFIG.world.h;

      const A = [
        [90, H*0.50],
        [220, H*0.20],
        [240, H*0.38],
        [240, H*0.62],
        [220, H*0.80],
        [360, H*0.22],
        [380, H*0.40],
        [380, H*0.60],
        [360, H*0.78],
        [520, H*0.32],
        [520, H*0.68],
      ];

      const B = [
        [W-90, H*0.50],
        [W-220, H*0.20],
        [W-240, H*0.38],
        [W-240, H*0.62],
        [W-220, H*0.80],
        [W-360, H*0.22],
        [W-380, H*0.40],
        [W-380, H*0.60],
        [W-360, H*0.78],
        [W-520, H*0.32],
        [W-520, H*0.68],
      ];

      for(let i=0;i<CONFIG.teams.count;i++) this.pegs.push(new Peg(A[i][0],A[i][1],'A',`A${i}`));
      for(let i=0;i<CONFIG.teams.count;i++) this.pegs.push(new Peg(B[i][0],B[i][1],'B',`B${i}`));

      for(const p of this.pegs){
        p.p.x += rand(-6,6);
        p.p.y += rand(-8,8);
      }
    }

    updateHUD(){
      this.ui.scoreA.textContent=String(this.scoreA);
      this.ui.scoreB.textContent=String(this.scoreB);
      this.ui.turnText.textContent=(this.turn==='A')?'Equipo A':'Equipo B';
      this.ui.turnPill.style.background=(this.turn==='A')?'#4da3ff':'#ff6b6b';
      this.ui.btnUndo.disabled = !this.undoSnap || this.phase!=='ready';
    }

    canShootNow(){
      return this.phase==='ready' && this.ball.speed()<0.5;
    }

    snapshot(){
      return {
        turn:this.turn, scoreA:this.scoreA, scoreB:this.scoreB,
        phase:this.phase, winner:this.winner,
        goalBannerUntil:this.goalBannerUntil, pauseUntil:this.pauseUntil,
        pendingCornerTeam:this.pendingCornerTeam,
        ball:{ p:{x:this.ball.p.x,y:this.ball.p.y}, v:{x:this.ball.v.x,y:this.ball.v.y} },
        pegs:this.pegs.map(p=>({ id:p.id, team:p.team, active:p.active })),
      };
    }

    applySnapshot(s){
      this.turn=s.turn; this.scoreA=s.scoreA; this.scoreB=s.scoreB;
      this.phase=s.phase; this.winner=s.winner;
      this.goalBannerUntil=s.goalBannerUntil||0;
      this.pauseUntil=s.pauseUntil||0;
      this.pendingCornerTeam=s.pendingCornerTeam||null;

      this.ball.p.x=s.ball.p.x; this.ball.p.y=s.ball.p.y;
      this.ball.v.x=s.ball.v.x; this.ball.v.y=s.ball.v.y;

      const map=new Map(this.pegs.map(p=>[p.id,p]));
      for(const sp of s.pegs){
        const p=map.get(sp.id);
        if(p) p.active=sp.active;
      }

      this.input.resetSelection();
      this.setCornerOverlay(this.phase==='waitingCorner');
      this.updateHUD();
    }

    undo(){
      if(!this.undoSnap) return;
      if(this.phase!=='ready') return;
      this.applySnapshot(this.undoSnap);
      this.undoSnap=null;
      this.updateHUD();
    }

    reset(){
      this.scoreA=0; this.scoreB=0;
      this.turn=(Math.random()<0.5)?'A':'B';
      this.phase='ready'; this.winner=null;

      this.ball.p.x=CONFIG.world.w/2; this.ball.p.y=CONFIG.world.h/2;
      this.ball.v.x=0; this.ball.v.y=0;

      this.buildFixedLayout();
      this.undoSnap=null;
      this.goalBannerUntil=0;
      this.pauseUntil=0;
      this.pendingCornerTeam=null;
      this.input.resetSelection();

      this.placeBallAtCornerForTeam(this.turn, Math.random()<0.5 ? 'top' : 'bottom');

      this.setCornerOverlay(false);
      this.updateHUD();
    }

    setCornerOverlay(show){
      document.getElementById('cornerOverlay').classList.toggle('show', !!show);
    }

    placeBallAtCornerForTeam(team, which){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const m=CONFIG.cornerMargin;
      this.ball.p.y = (which==='top') ? m : (H-m);
      this.ball.p.x = (team==='A') ? m : (W-m);
      this.ball.v.x=0; this.ball.v.y=0;
    }

    onShot(){
      this.undoSnap=this.snapshot();
      this.phase='sim';
      this.simStartMs=nowMs();
      this.updateHUD();
    }

    allStopped(){
      return this.ball.speed() <= CONFIG.physics.stopSpeed;
    }

    checkGoal(){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const open=CONFIG.goal.opening;
      const yTop=(H-open)/2, yBot=yTop+open;
      const b=this.ball;

      const inMouth = (b.p.y>=yTop && b.p.y<=yBot);
      if(inMouth && (b.p.x + b.r < 0)) return { scorer:'B', conceded:'A' };
      if(inMouth && (b.p.x - b.r > W)) return { scorer:'A', conceded:'B' };
      return null;
    }

    removeOnePeg(team){
      const candidates=this.pegs.filter(p=>p.active && p.team===team);
      if(!candidates.length) return;

      const targetX = (team==='A') ? 0 : CONFIG.world.w;
      let best=candidates[0], bestScore=Infinity;
      for(const p of candidates){
        const score = Math.abs(p.p.x - targetX) * 1.0 + Math.abs(p.p.y - CONFIG.world.h/2) * 0.15;
        if(score < bestScore){ bestScore=score; best=p; }
      }
      best.active=false;
    }

    applyGoal(g){
      if(g.scorer==='A') this.scoreA++; else this.scoreB++;
      this.removeOnePeg(g.conceded);

      this.goalBannerUntil=nowMs()+CONFIG.effects.goalBannerMs;
      document.getElementById('goalBanner').classList.add('show');

      this.ball.v.x=0; this.ball.v.y=0;

      if(this.scoreA>=11 || this.scoreB>=11){
        this.phase='gameover';
        this.winner=(this.scoreA>=11)?'A':'B';
        this.pendingCornerTeam=null;
        this.setCornerOverlay(false);
        this.updateHUD();
        return;
      }

      // Tras gol: saca el equipo que encaja y elige esquina
      this.turn = g.conceded;
      this.pendingCornerTeam = g.conceded;

      this.phase='waitingCorner';
      this.input.resetSelection();

      const teamName = (this.pendingCornerTeam==='A') ? 'Equipo A' : 'Equipo B';
      document.getElementById('cornerTitle').textContent = `Saque tras gol · ${teamName}`;
      document.getElementById('cornerDesc').textContent = `El ${teamName} recibió el gol. Elige una de tus dos esquinas para sacar.`;
      this.setCornerOverlay(true);

      this.updateHUD();
    }

    chooseCorner(which){
      if(this.phase!=='waitingCorner') return;
      const team=this.pendingCornerTeam;
      if(!team) return;

      this.placeBallAtCornerForTeam(team, which);

      this.pendingCornerTeam=null;
      this.setCornerOverlay(false);

      this.pauseUntil=nowMs()+CONFIG.effects.goalPauseMs;
      this.phase='paused';
      this.updateHUD();
    }

    drawGameOverOverlay(){
      const ctx=this.renderer.ctx;
      const w=this.renderer.w, h=this.renderer.h;
      const dpr=this.renderer.dpr;

      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.35)';
      ctx.fillRect(0,0,w,h);

      const text=(this.winner==='A')?'¡GANA EQUIPO A!':'¡GANA EQUIPO B!';
      ctx.font=`1000 ${Math.floor(54*dpr)}px system-ui`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(255,255,255,.92)';
      ctx.shadowColor='rgba(0,0,0,.45)';
      ctx.shadowBlur=18*dpr;
      ctx.fillText(text,w/2,h/2-22*dpr);
      ctx.shadowBlur=0;

      ctx.font=`800 ${Math.floor(16*dpr)}px system-ui`;
      ctx.fillStyle='rgba(234,240,255,.85)';
      ctx.fillText('Pulsa “Reiniciar partido” para jugar otra vez.',w/2,h/2+28*dpr);
      ctx.restore();
    }

    loop(){
      const t=nowMs();
      const dtFrame=Math.min((t-this.last)/1000, 0.05);
      this.last=t;
      this.acc += dtFrame;

      if(t>=this.goalBannerUntil){
        document.getElementById('goalBanner').classList.remove('show');
      }

      if(this.phase==='paused' && t>=this.pauseUntil){
        this.phase='ready';
        this.updateHUD();
      }

      if(this.phase==='sim'){
        const fixed=CONFIG.physics.dt;
        let steps=0;
        while(this.acc>=fixed && steps<CONFIG.physics.maxSubStepsPerFrame){
          this.physics.step(fixed);
          this.acc -= fixed;
          steps++;
        }

        const goal=this.checkGoal();
        if(goal){
          this.applyGoal(goal);
        }else{
          const elapsed=(t-this.simStartMs)/1000;
          if(this.allStopped() || elapsed>=CONFIG.physics.maxSimSeconds){
            this.ball.v.x=0; this.ball.v.y=0;
            this.phase='ready';
            this.turn=(this.turn==='A')?'B':'A';
            this.input.resetSelection();
            this.updateHUD();
          }
        }
      }

      this.renderer.draw();
      if(this.phase==='gameover') this.drawGameOverOverlay();

      requestAnimationFrame(()=>this.loop());
    }
  }

  const canvas=document.getElementById('c');
  const shell=document.getElementById('shell');
  new Game(canvas,shell);

  document.getElementById('help').addEventListener('click', ()=>document.getElementById('helpBack').classList.add('show'));
  document.getElementById('closeHelp').addEventListener('click', ()=>document.getElementById('helpBack').classList.remove('show'));
  document.getElementById('helpBack').addEventListener('click', (e)=>{
    if(e.target.id==='helpBack') document.getElementById('helpBack').classList.remove('show');
  });
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Escape') document.getElementById('helpBack').classList.remove('show');
  });
})();
</script>

<!--
============================================================
CÓMO JUGAR
============================================================
- Control tipo TIRACHINAS:
  - Click/toca la bola → arrastra hacia atrás (carga) → suelta.
  - La flecha se muestra hacia atrás (dirección de carga).
  - La bola sale hacia delante (dirección opuesta al arrastre).
- Palitos fijos: solo obstáculos. Se quitan al encajar gol y se ven en el borde.
- Tras gol: saca el equipo que encaja y elige esquina superior/inferior.
- Si no hay gol: se juega desde donde quedó la bola.

============================================================
PARÁMETROS PARA AJUSTAR
============================================================
- CONFIG.shot.minSpeed / maxSpeed: rango de velocidades del tiro.
- CONFIG.shot.responseCurve: 1.2..2.4 (más alto = más suave al principio).
- CONFIG.ball.damp y CONFIG.ball.maxSpeed.
-->
</body>
</html>
