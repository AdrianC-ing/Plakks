<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PLAKKS-like Flick Soccer (Static Pegs)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#eaf0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .wrap{height:100%;display:flex;flex-direction:column;padding:12px;gap:10px;max-width:1200px;margin:0 auto;}
    .top{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
    }
    .title{font-weight:900;letter-spacing:.2px;font-size:15px;display:flex;gap:10px;align-items:center}
    .badge{font-weight:800;font-size:12px;padding:3px 8px;border-radius:999px;background:rgba(125,211,252,.14);border:1px solid rgba(125,211,252,.35);color:#c9f2ff}
    .sub{font-size:12px;opacity:.75;margin-top:2px}
    .hud{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
    .score{
      display:flex;align-items:center;gap:10px;padding:8px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);
      min-width:190px;justify-content:space-between
    }
    .teamTag{display:flex;align-items:center;gap:8px;font-weight:900;font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%;box-shadow:0 0 0 3px rgba(255,255,255,.06)}
    .dotA{background:#4da3ff}
    .dotB{background:#ff6b6b}
    .scoreNum{font-weight:1000;font-size:20px;letter-spacing:.6px}
    .turn{
      padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);font-weight:900;font-size:12px;display:flex;gap:8px;align-items:center
    }
    .pill{width:10px;height:10px;border-radius:50%;box-shadow:0 0 0 3px rgba(255,255,255,.06)}
    .btnRow{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    button{
      cursor:pointer;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);color:#eaf0ff;
      padding:8px 10px;border-radius:12px;font-weight:800;font-size:12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 10px 20px rgba(0,0,0,.18);
    }
    button:active{transform:translateY(1px)}
    button.secondary{border-color:rgba(167,139,250,.35);background:rgba(167,139,250,.12)}
    button.danger{border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.12)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .shell{
      position:relative;flex:1;border-radius:16px;border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);overflow:hidden;min-height:520px;
      box-shadow: 0 18px 42px rgba(0,0,0,.32);
      display:flex;flex-direction:column;
    }

    .bottomBar{
      display:flex;align-items:flex-end;gap:10px;
      padding:10px 10px 10px;
      border-top:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.22));
    }

    .playArea{
      position:relative;
      flex:1;
      min-height:360px;
    }

    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:#091022}

    .goalBanner{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;
      opacity:0;transition:opacity .18s ease;z-index:8;
    }
    .goalBanner.show{opacity:1}
    .goalText{
      font-weight:1000;letter-spacing:2px;font-size:clamp(44px,7vw,92px);
      padding:10px 22px;border-radius:20px;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.15);
      box-shadow:0 24px 80px rgba(0,0,0,.45);text-shadow:0 16px 30px rgba(0,0,0,.45);
      transform:translateY(10px) scale(.98);transition:transform .18s ease;
    }
    .goalBanner.show .goalText{transform:translateY(0) scale(1)}

    .modalBack{
      position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;padding:16px;z-index:50;
    }
    .modalBack.show{display:flex}
    .modal{
      width:min(760px,100%);border-radius:16px;border:1px solid rgba(255,255,255,.12);
      background:rgba(15,26,47,.96);box-shadow:0 30px 100px rgba(0,0,0,.55);
      padding:16px 16px 12px;
    }
    .modal h2{margin:0 0 8px;font-size:16px}
    .modal p,.modal li{font-size:13px;line-height:1.45;color:rgba(234,240,255,.85)}
    .modal ul{margin:8px 0 0 18px}
    .modal .top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px;padding:0;border:0;background:none;box-shadow:none}

    /* ✅ Overlay NO bloqueante: deja pasar toques al canvas.
       Solo el panel recibe interacción (pointer-events:auto). */
    .overlay{
      position:absolute;inset:0;display:none;align-items:flex-start;justify-content:center;
      z-index:20;
      pointer-events:none;              /* <- clave */
      padding:12px;
    }
    .overlay.show{display:flex}

    .panel{
      pointer-events:auto;              /* <- solo el panel captura clics */
      width:min(560px,calc(100% - 24px));
      border-radius:16px;border:1px solid rgba(255,255,255,.14);
      background:rgba(15,26,47,.94);
      box-shadow:0 26px 90px rgba(0,0,0,.55);
      padding:14px;
      backdrop-filter: blur(4px);
    }
    .panel h3{margin:0 0 6px;font-size:15px}
    .panel p{margin:0 0 12px;font-size:13px;line-height:1.4;color:rgba(234,240,255,.82)}
    .choiceRow{display:flex;gap:10px;flex-wrap:wrap}
    .choiceRow button{flex:1;min-width:150px}
    .hint{margin-top:10px;font-size:12px;color:rgba(234,240,255,.70)}

    .hintCard{
      flex:1;
      padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.26);
      border:1px solid rgba(255,255,255,.10);
      color:rgba(234,240,255,.86);
      font-size:12px;line-height:1.35;
      max-width:900px;
      user-select:none;
    }
    .hintHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      font-weight:900;color:#fff;
    }
    .chev{opacity:.75}
    .hintBody{margin-top:6px}
    .hintCard.compact .hintBody{display:none}
    .hintCard.compact{max-width:520px}
    .hintCard .kbd{
      display:inline-block;padding:1px 6px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      font-weight:800;font-size:11px;opacity:.95
    }

    @media(max-width:720px){
      .top{flex-direction:column;align-items:stretch}
      .btnRow button{flex:1}
      .shell{min-height:62vh}
      .hintCard{max-width:unset}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <div class="title">PLAKKS-like Flick Soccer <span class="badge">overlay no bloquea</span></div>
      <div class="sub">Ahora el mensaje de “Retirar palito” no impide tocar el campo</div>
    </div>
    <div class="hud">
      <div class="score" aria-label="Marcador">
        <div class="teamTag"><span class="dot dotA"></span>Equipo A</div>
        <div class="scoreNum"><span id="scoreA">0</span> – <span id="scoreB">0</span></div>
        <div class="teamTag">Equipo B<span class="dot dotB"></span></div>
      </div>
      <div class="turn" aria-label="Turno">
        <span>Turno:</span><span class="pill" id="turnPill"></span><span id="turnText">Equipo A</span>
      </div>
      <div class="btnRow">
        <button id="undo" class="secondary">Deshacer último tiro</button>
        <button id="reset" class="danger">Reiniciar partido</button>
        <button id="help">Ayuda</button>
      </div>
    </div>
  </div>

  <div class="shell" id="shell">
    <div class="playArea" id="playArea">
      <canvas id="c"></canvas>
      <div class="goalBanner" id="goalBanner"><div class="goalText">GOOOL</div></div>

      <div class="overlay" id="removeOverlay">
        <div class="panel">
          <h3 id="removeTitle">Elige el palito a retirar</h3>
          <p id="removeDesc">Te han metido gol. Toca uno de tus palitos para retirarlo (quedará tumbado fuera del campo).</p>
          <div class="hint">Ahora puedes tocar palitos aunque este panel esté visible (no bloquea el campo).</div>
        </div>
      </div>

      <div class="overlay" id="cornerOverlay">
        <div class="panel">
          <h3 id="cornerTitle">Elige esquina para sacar</h3>
          <p id="cornerDesc">El equipo que recibió el gol saca ahora. Elige una de tus dos esquinas.</p>
          <div class="choiceRow">
            <button id="cornerTop" class="secondary">Esquina superior</button>
            <button id="cornerBottom" class="secondary">Esquina inferior</button>
          </div>
          <div class="hint">Después del saque, la bola se juega desde donde se quede.</div>
        </div>
      </div>
    </div>

    <div class="bottomBar" id="bottomBar">
      <div class="hintCard" id="hintCard" role="button" tabindex="0" aria-expanded="true" title="Toca para plegar/desplegar">
        <div class="hintHead">
          <span>Controles</span>
          <span class="chev" id="hintChev">▾</span>
        </div>
        <div class="hintBody" id="hintBody">
          <div><b>Chute:</b> toca la bola → arrastra <b>hacia atrás</b> → suelta.</div>
          <div><b>Tras gol:</b> el equipo que encaja elige qué palito retirar, luego elige esquina para sacar.</div>
          <div style="margin-top:6px;opacity:.85">
            Tip móvil: toca aquí para <span class="kbd">plegar</span>.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modalBack" id="helpBack" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="modal">
    <div class="top">
      <h2 id="helpTitle">Ayuda · Reglas y controles</h2>
      <button id="closeHelp">Cerrar</button>
    </div>
    <ul>
      <li><b>Turnos:</b> alternan A/B. En tu turno haces <b>un</b> chute con la <b>bola</b>.</li>
      <li><b>Tirachinas:</b> arrastra hacia atrás para cargar; la bola sale hacia delante.</li>
      <li><b>Gol:</b> cuando la bola cruza completamente la línea x=0 o x=W dentro del hueco de la portería.</li>
      <li><b>Tras gol:</b> el equipo que encaja <b>elige</b> qué palito retirar; el palito queda tumbado fuera del campo.</li>
      <li><b>Saque:</b> después eliges una de tus dos esquinas.</li>
    </ul>
  </div>
</div>

<script>
(() => {
  const CONFIG = {
    world: { w: 1200, h: 720 },

    goal: {
      opening: 220,
      boxDepth: 92,
      boxDepthPhysics: 110,
      netCell: 18,
      innerPad: 10
    },

    ball: { r: 16, restitution: 0.90, damp: 0.994, maxSpeed: 1800 },
    peg:  { r: 24, restitution: 0.55 },
    teams: { count: 11 },

    shot: {
      minSpeed: 140,
      maxSpeed: 980,
      responseCurve: 1.8,
      aimLineW: 3,
      maxDragFrac: 0.18,
      minDragCssPx: 90,
      maxDragCssPx: 160
    },

    physics: {
      dt: 1/120,
      maxSubStepsPerFrame: 10,
      solverIterations: 2,
      wallRestitution: 0.86,
      netRestitution: 0.55,
      stopSpeed: 14,
      maxSimSeconds: 4.0,
      penetrationSlop: 0.02,
      penetrationPercent: 0.92,
    },

    render: {
      pitchMargin: 34,
      pitchCornerR: 38,
      grassNoise: 0.06,
      shadowOffset: { x: 10, y: 14 },
      shadowBlur: 16,
      vignette: true,

      removed: {
        scale: 0.78,
        alpha: 0.82,
        pad: 10,
        gap: 10,
        lieAngleBase: Math.PI/2,
        lieAngleJitter: 0.28
      },

      pegVisual: {
        widthMul: 1.05,
        lengthMul: 2.65,
        tiltA: -0.18,
        tiltB:  0.18,
        shadowRxMul: 0.85,
        shadowRyMul: 0.30
      },

      ballPickExtraCssPx: 18,
      pegPickExtraCssPx: 10
    },

    effects: { goalBannerMs: 850, goalPauseMs: 520 },
    cornerMargin: 52,
  };

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const nowMs = ()=>performance.now();
  const rand = (a,b)=>a+Math.random()*(b-a);

  class Vec2{
    constructor(x=0,y=0){this.x=x;this.y=y;}
    mag(){return Math.hypot(this.x,this.y);}
    mul(s){this.x*=s;this.y*=s;return this;}
  }

  class Ball{
    constructor(x,y){
      this.p=new Vec2(x,y);
      this.v=new Vec2(0,0);
      this.r=CONFIG.ball.r;
      this.restitution=CONFIG.ball.restitution;
      this.damp=CONFIG.ball.damp;
      this.maxSpeed=CONFIG.ball.maxSpeed;
    }
    speed(){return this.v.mag();}
  }

  class Peg{
    constructor(x,y,team,id){
      this.p=new Vec2(x,y);
      this.r=CONFIG.peg.r;
      this.team=team;
      this.id=id;
      this.active=true;
      this.removedPose=null;
    }
  }

  class Physics{
    constructor(game){this.game=game;}

    mouthYBounds(){
      const H=CONFIG.world.h;
      const open=CONFIG.goal.opening;
      const yTop=(H-open)/2, yBot=yTop+open;
      return {yTop,yBot};
    }

    inMouth(y){
      const {yTop,yBot}=this.mouthYBounds();
      return (y>=yTop && y<=yBot);
    }

    step(dt){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const b=this.game.ball;

      b.p.x += b.v.x*dt;
      b.p.y += b.v.y*dt;

      b.v.mul(b.damp);

      const s=b.speed();
      if(s>b.maxSpeed){
        const k=b.maxSpeed/(s+1e-9);
        b.v.mul(k);
      }

      const e=CONFIG.physics.wallRestitution;
      const en=CONFIG.physics.netRestitution;
      const inMouth = this.inMouth(b.p.y);
      const dPhys = CONFIG.goal.boxDepthPhysics;

      if(!inMouth){
        if(b.p.x-b.r<0){ b.p.x=b.r; b.v.x=Math.abs(b.v.x)*e; }
        if(b.p.x+b.r>W){ b.p.x=W-b.r; b.v.x=-Math.abs(b.v.x)*e; }
      }else{
        if(b.p.x - b.r < -dPhys){
          b.p.x = -dPhys + b.r;
          b.v.x = Math.abs(b.v.x) * en;
        }
        if(b.p.x + b.r > W + dPhys){
          b.p.x = W + dPhys - b.r;
          b.v.x = -Math.abs(b.v.x) * en;
        }
      }

      if(b.p.y-b.r<0){ b.p.y=b.r; b.v.y=Math.abs(b.v.y)*e; }
      if(b.p.y+b.r>H){ b.p.y=H-b.r; b.v.y=-Math.abs(b.v.y)*e; }

      for(let it=0; it<CONFIG.physics.solverIterations; it++){
        for(const p of this.game.pegs){
          if(!p.active) continue;
          this.resolveBallPeg(b,p);
        }
      }
    }

    resolveBallPeg(ball, peg){
      const dx=ball.p.x-peg.p.x, dy=ball.p.y-peg.p.y;
      let dist=Math.hypot(dx,dy);
      const r=ball.r+peg.r;
      if(dist<=0) dist=0.0001;

      if(dist<r){
        const penetration=r-dist;
        const nx=dx/dist, ny=dy/dist;

        const slop=CONFIG.physics.penetrationSlop;
        const percent=CONFIG.physics.penetrationPercent;
        const corr=Math.max(penetration-slop,0)*percent;

        ball.p.x += nx*corr;
        ball.p.y += ny*corr;

        const velAlong = ball.v.x*nx + ball.v.y*ny;
        if(velAlong<0){
          const e = Math.min(ball.restitution, CONFIG.peg.restitution);
          ball.v.x = ball.v.x - (1+e)*velAlong*nx;
          ball.v.y = ball.v.y - (1+e)*velAlong*ny;

          const tx = ball.v.x - (ball.v.x*nx+ball.v.y*ny)*nx;
          const ty = ball.v.y - (ball.v.x*nx+ball.v.y*ny)*ny;
          const tmag = Math.hypot(tx,ty);
          if(tmag>1e-6){
            ball.v.x -= (tx/tmag)*3.0;
            ball.v.y -= (ty/tmag)*3.0;
          }
        }
      }
    }
  }

  class Renderer{
    constructor(game,canvas,playArea){
      this.game=game; this.canvas=canvas; this.playArea=playArea;
      this.ctx=canvas.getContext('2d');

      this.noise=document.createElement('canvas');
      this.noise.width=256; this.noise.height=256;
      this.noiseCtx=this.noise.getContext('2d');
      this.buildNoise();

      this.scale=1; this.ox=0; this.oy=0; this.w=0; this.h=0; this.dpr=1;
    }

    buildNoise(){
      const img=this.noiseCtx.createImageData(256,256);
      for(let i=0;i<img.data.length;i+=4){
        const n=(Math.random()*2-1)*255;
        img.data[i]=0;
        img.data[i+1]=120+n*0.08;
        img.data[i+2]=0;
        img.data[i+3]=255;
      }
      this.noiseCtx.putImageData(img,0,0);
    }

    resize(){
      const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
      const r=this.playArea.getBoundingClientRect();
      const cssW=Math.max(300, r.width||900);
      const cssH=Math.max(300, r.height||540);
      const w=Math.floor(cssW*dpr);
      const h=Math.floor(cssH*dpr);
      if(this.canvas.width!==w||this.canvas.height!==h){this.canvas.width=w;this.canvas.height=h;}

      const pad=CONFIG.render.pitchMargin*dpr;
      const sx=(w-pad*2)/CONFIG.world.w;
      const sy=(h-pad*2)/CONFIG.world.h;
      const scale=Math.max(0.0001, Math.min(sx,sy));

      this.dpr=dpr; this.w=w; this.h=h; this.scale=scale;
      this.ox=(w-CONFIG.world.w*scale)*0.5;
      this.oy=(h-CONFIG.world.h*scale)*0.5;
    }

    w2s(p){ return { x:this.ox+p.x*this.scale, y:this.oy+p.y*this.scale }; }

    maxDragPx(){
      const minSide = Math.min(this.w, this.h);
      const desired = minSide * CONFIG.shot.maxDragFrac;
      const minD = CONFIG.shot.minDragCssPx * this.dpr;
      const maxD = CONFIG.shot.maxDragCssPx * this.dpr;
      return clamp(desired, minD, maxD);
    }

    roundRect(x,y,w,h,r){
      const ctx=this.ctx;
      const rr=Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }

    grassFillAt(x0,y0,w,h){
      const ctx=this.ctx;
      const g=ctx.createLinearGradient(x0,y0,x0+w,y0+h);
      g.addColorStop(0,'#0f6b3c');
      g.addColorStop(0.5,'#0e5f37');
      g.addColorStop(1,'#0b4a2c');
      return g;
    }

    drawPitch(){
      const ctx=this.ctx;
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const x0=this.ox, y0=this.oy, s=this.scale;
      const r=CONFIG.render.pitchCornerR*this.dpr;

      const open=CONFIG.goal.opening;
      const yTop=(H-open)/2;
      const gy0=y0+yTop*s;
      const gh=open*s;
      const gDepth=CONFIG.goal.boxDepth*s;

      ctx.save();
      ctx.fillStyle=this.grassFillAt(x0,y0,W*s,H*s);
      this.roundRect(x0,y0,W*s,H*s,r);
      ctx.fill();

      ctx.globalAlpha=0.13;
      for(let i=0;i<10;i++){
        const yy=y0+(H*s)*(i/10);
        ctx.fillStyle=(i%2===0)?'#0b4f2f':'#0f7343';
        ctx.fillRect(x0,yy,W*s,(H*s)/10);
      }
      ctx.globalAlpha=1;

      ctx.globalAlpha=CONFIG.render.grassNoise;
      ctx.drawImage(this.noise,x0,y0,W*s,H*s);
      ctx.globalAlpha=1;

      ctx.fillStyle='rgba(0,0,0,.10)';
      ctx.fillRect(x0-gDepth, gy0, gDepth, gh);
      ctx.fillRect(x0+W*s,  gy0, gDepth, gh);

      ctx.lineWidth=3*this.dpr;
      ctx.strokeStyle='rgba(245,255,245,.85)';
      this.roundRect(x0+2*this.dpr,y0+2*this.dpr,W*s-4*this.dpr,H*s-4*this.dpr,Math.max(2,r-6*this.dpr));
      ctx.stroke();

      ctx.save();
      ctx.strokeStyle=this.grassFillAt(x0,y0,W*s,H*s);
      ctx.lineWidth=8*this.dpr;
      ctx.beginPath(); ctx.moveTo(x0, gy0); ctx.lineTo(x0, gy0+gh); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x0+W*s, gy0); ctx.lineTo(x0+W*s, gy0+gh); ctx.stroke();
      ctx.restore();

      ctx.lineWidth=3*this.dpr;
      ctx.strokeStyle='rgba(245,255,245,.88)';
      ctx.strokeRect(x0-gDepth, gy0, gDepth, gh);
      ctx.strokeRect(x0+W*s,  gy0, gDepth, gh);

      ctx.lineWidth=3*this.dpr;
      ctx.strokeStyle='rgba(245,255,245,.85)';
      ctx.beginPath();
      ctx.moveTo(x0+(W*s)/2, y0+2*this.dpr);
      ctx.lineTo(x0+(W*s)/2, y0+H*s-2*this.dpr);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(x0+(W*s)/2,y0+(H*s)/2,110*s,0,Math.PI*2);
      ctx.stroke();

      ctx.fillStyle='rgba(245,255,245,.95)';
      ctx.beginPath();
      ctx.arc(x0+(W*s)/2,y0+(H*s)/2,5*this.dpr,0,Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    drawGoals(){
      const ctx=this.ctx;
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const open=CONFIG.goal.opening;
      const depth=CONFIG.goal.boxDepth;
      const pad=CONFIG.goal.innerPad;
      const cell=CONFIG.goal.netCell;

      const yTop=(H-open)/2;
      const y0 = this.oy + yTop*this.scale;
      const h = open*this.scale;
      const d = depth*this.scale;

      const drawNet = (x, y, w, hh, alpha=0.22) => {
        ctx.save();
        ctx.globalAlpha=alpha;
        ctx.strokeStyle='rgba(255,255,255,.75)';
        ctx.lineWidth=1.1*this.dpr;
        for(let yy=y; yy<=y+hh+0.001; yy+=cell*this.scale){
          ctx.beginPath(); ctx.moveTo(x,yy); ctx.lineTo(x+w,yy); ctx.stroke();
        }
        for(let xx=x; xx<=x+w+0.001; xx+=cell*this.scale){
          ctx.beginPath(); ctx.moveTo(xx,y); ctx.lineTo(xx,y+hh); ctx.stroke();
        }
        ctx.restore();
      };

      const drawBox = (isLeft) => {
        const xLine = this.ox + (isLeft ? 0 : W*this.scale);
        const boxX = isLeft ? (xLine - d) : xLine;
        const boxY = y0;

        ctx.save();
        const bg = ctx.createLinearGradient(
          boxX, boxY,
          isLeft ? (boxX - d) : (boxX + d),
          boxY
        );
        bg.addColorStop(0,'rgba(0,0,0,.10)');
        bg.addColorStop(1,'rgba(0,0,0,.34)');
        ctx.fillStyle=bg;
        ctx.fillRect(boxX, boxY, d, h);

        const innerX = boxX + pad*this.scale;
        const innerY = boxY + pad*this.scale;
        const innerW = d - 2*pad*this.scale;
        const innerH = h - 2*pad*this.scale;
        drawNet(innerX, innerY, innerW, innerH, 0.22);

        ctx.lineWidth=5*this.dpr;
        ctx.strokeStyle='rgba(255,255,255,.85)';
        ctx.beginPath();
        ctx.moveTo(xLine, boxY);
        ctx.lineTo(xLine, boxY+h);
        ctx.stroke();

        ctx.lineWidth=2.3*this.dpr;
        ctx.strokeStyle='rgba(255,255,255,.72)';
        ctx.strokeRect(boxX, boxY, d, h);
        ctx.restore();
      };

      drawBox(true);
      drawBox(false);
    }

    drawShadowEllipse(x,y,rx,ry,alpha=0.35){
      const ctx=this.ctx;
      const off=CONFIG.render.shadowOffset;
      const sx=x+off.x*this.dpr;
      const sy=y+off.y*this.dpr;
      ctx.save();
      ctx.globalAlpha=alpha;
      ctx.fillStyle='rgba(0,0,0,.55)';
      ctx.shadowColor='rgba(0,0,0,.55)';
      ctx.shadowBlur=CONFIG.render.shadowBlur*this.dpr;
      ctx.beginPath();
      ctx.ellipse(sx,sy,rx,ry,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    drawBall(ball, selected){
      const ctx=this.ctx;
      const p=this.w2s(ball.p);
      const r=ball.r*this.scale;

      this.drawShadowEllipse(p.x,p.y,r*1.05,r*0.78,0.40);

      ctx.save();
      const g=ctx.createRadialGradient(p.x-r*0.35,p.y-r*0.35,r*0.35,p.x,p.y,r*1.15);
      g.addColorStop(0,'rgba(255,255,255,.98)');
      g.addColorStop(0.35,'rgba(255,255,255,.92)');
      g.addColorStop(0.7,'rgba(220,230,255,.88)');
      g.addColorStop(1,'rgba(140,160,190,.85)');
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.18)';
      ctx.lineWidth=1.3*this.dpr;
      ctx.stroke();

      ctx.globalAlpha=0.55;
      ctx.fillStyle='rgba(255,255,255,.85)';
      ctx.beginPath();
      ctx.ellipse(p.x-r*0.25,p.y-r*0.35,r*0.35,r*0.25,-0.6,0,Math.PI*2);
      ctx.fill();

      if(selected){
        ctx.globalAlpha=1;
        ctx.strokeStyle='rgba(125,211,252,.95)';
        ctx.lineWidth=3*this.dpr;
        ctx.beginPath();
        ctx.arc(p.x,p.y,r+4*this.dpr,0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }

    drawPegRodScreen(x,y,rScreen,team,dimmed=false,alpha=1,forcedRot=null){
      const ctx=this.ctx;
      const base=(team==='A')?{a:'#4da3ff',b:'#124fae'}:{a:'#ff6b6b',b:'#b81f3d'};
      const pv=CONFIG.render.pegVisual;

      const w = rScreen * pv.widthMul * 1.15;
      const h = rScreen * pv.lengthMul;
      const rr = w * 0.55;
      const rot = (forcedRot!==null) ? forcedRot : ((team==='A') ? pv.tiltA : pv.tiltB);

      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(rot);

      ctx.globalAlpha = alpha;
      const lg = ctx.createLinearGradient(-w*0.65, 0, w*0.65, 0);
      lg.addColorStop(0,'rgba(255,255,255,.10)');
      lg.addColorStop(0.22,base.a);
      lg.addColorStop(0.55,base.b);
      lg.addColorStop(0.85,base.a);
      lg.addColorStop(1,'rgba(0,0,0,.15)');

      ctx.fillStyle = lg;
      this.roundRect(-w/2, -h/2, w, h, rr);
      ctx.fill();

      ctx.strokeStyle='rgba(0,0,0,.20)';
      ctx.lineWidth=1.2*this.dpr;
      ctx.stroke();

      ctx.globalAlpha = alpha * (dimmed ? 0.25 : 0.40);
      const hg = ctx.createLinearGradient(-w/2,0,w/2,0);
      hg.addColorStop(0,'rgba(255,255,255,0)');
      hg.addColorStop(0.35,'rgba(255,255,255,.55)');
      hg.addColorStop(0.55,'rgba(255,255,255,.12)');
      hg.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle = hg;
      this.roundRect(-w*0.42, -h*0.46, w*0.84, h*0.92, rr*0.95);
      ctx.fill();

      if(dimmed){
        ctx.globalAlpha = alpha * 0.25;
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        this.roundRect(-w/2, -h/2, w, h, rr);
        ctx.fill();
      }

      ctx.restore();
    }

    drawPeg(peg, highlight=false, selectable=false){
      const p=this.w2s(peg.p);
      const r=peg.r*this.scale;
      const pv=CONFIG.render.pegVisual;

      const rx = r * pv.shadowRxMul;
      const ry = r * pv.lengthMul * pv.shadowRyMul;
      this.drawShadowEllipse(p.x,p.y,rx,ry,0.32);

      this.drawPegRodScreen(p.x,p.y,r,peg.team,false,1);

      const ctx=this.ctx;
      if(selectable){
        ctx.save();
        ctx.globalAlpha=0.95;
        ctx.strokeStyle='rgba(255,255,255,.65)';
        ctx.lineWidth=2.2*this.dpr;
        ctx.beginPath();
        ctx.arc(p.x,p.y,r+7*this.dpr,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
      if(highlight){
        ctx.save();
        ctx.strokeStyle='rgba(125,211,252,.95)';
        ctx.lineWidth=3.2*this.dpr;
        ctx.beginPath();
        ctx.arc(p.x,p.y,r+8*this.dpr,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }

    drawAim(input){
      if(!input.aiming || !input.ballSelected) return;
      const ctx=this.ctx;
      const ball=this.game.ball;
      const bp=this.w2s(ball.p);
      const m=input.mouse;

      const dx=m.x-bp.x, dy=m.y-bp.y;
      const dist=Math.hypot(dx,dy);

      const maxD=this.maxDragPx();
      const clamped=Math.min(dist,maxD);
      const t=clamp(clamped/maxD,0,1);

      ctx.save();
      ctx.lineWidth=CONFIG.shot.aimLineW*this.dpr;
      ctx.lineCap='round';
      ctx.strokeStyle=`rgba(125,211,252,${0.20+0.65*t})`;
      ctx.shadowColor='rgba(0,0,0,.35)';
      ctx.shadowBlur=10*this.dpr;

      const k=(dist>1e-6)?(clamped/dist):0;
      const ex=bp.x+dx*k, ey=bp.y+dy*k;

      ctx.beginPath();
      ctx.moveTo(bp.x,bp.y);
      ctx.lineTo(ex,ey);
      ctx.stroke();

      const ang=Math.atan2(dy,dx);
      const ah=10*this.dpr;
      ctx.beginPath();
      ctx.moveTo(ex,ey);
      ctx.lineTo(ex-Math.cos(ang-0.55)*ah, ey-Math.sin(ang-0.55)*ah);
      ctx.lineTo(ex-Math.cos(ang+0.55)*ah, ey-Math.sin(ang+0.55)*ah);
      ctx.closePath();
      ctx.fillStyle=`rgba(125,211,252,${0.25+0.60*t})`;
      ctx.fill();

      const bw=190*this.dpr, bh=10*this.dpr;
      const bx=this.ox+14*this.dpr, by=this.oy+(CONFIG.world.h*this.scale)-20*this.dpr;
      ctx.shadowBlur=0;
      ctx.fillStyle='rgba(0,0,0,.25)';
      this.roundRect(bx,by,bw,bh,6*this.dpr); ctx.fill();

      const pw=bw*t;
      const pg=ctx.createLinearGradient(bx,by,bx+bw,by);
      pg.addColorStop(0,'rgba(52,211,153,.9)');
      pg.addColorStop(0.55,'rgba(125,211,252,.9)');
      pg.addColorStop(1,'rgba(251,113,133,.9)');
      ctx.fillStyle=pg;
      this.roundRect(bx,by,pw,bh,6*this.dpr); ctx.fill();

      ctx.restore();
    }

    drawRemovedPegs(){
      const remCfg=CONFIG.render.removed;
      const pv=CONFIG.render.pegVisual;

      const removed = this.game.pegs.filter(p=>!p.active && p.removedPose);
      for(const p of removed){
        const sp = this.w2s({x:p.removedPose.x, y:p.removedPose.y});
        const r = (p.r*this.scale) * remCfg.scale;

        const rx = r * pv.shadowRxMul;
        const ry = r * pv.lengthMul * pv.shadowRyMul;
        this.drawShadowEllipse(sp.x,sp.y,rx,ry,0.18);

        this.drawPegRodScreen(sp.x, sp.y, r, p.team, true, remCfg.alpha, p.removedPose.angle);
      }
    }

    drawVignette(){
      if(!CONFIG.render.vignette) return;
      const ctx=this.ctx;
      const w=this.w, h=this.h;
      const g=ctx.createRadialGradient(w*0.5,h*0.5,Math.min(w,h)*0.25,w*0.5,h*0.5,Math.max(w,h)*0.65);
      g.addColorStop(0,'rgba(0,0,0,0)');
      g.addColorStop(1,'rgba(0,0,0,.35)');
      ctx.save();
      ctx.fillStyle=g;
      ctx.fillRect(0,0,w,h);
      ctx.restore();
    }

    draw(){
      this.resize();
      const ctx=this.ctx;
      ctx.clearRect(0,0,this.w,this.h);

      this.drawPitch();
      this.drawGoals();

      const choosing = (this.game.phase==='chooseRemoval');
      const mustTeam = this.game.pendingRemovalTeam;

      for(const p of this.game.pegs){
        if(!p.active) continue;
        const selectable = choosing && (p.team===mustTeam);
        const highlight = selectable && (this.game.hoverPegId===p.id);
        this.drawPeg(p, highlight, selectable);
      }

      this.drawBall(this.game.ball, this.game.input.ballSelected);
      this.drawRemovedPegs();
      this.drawAim(this.game.input);
      this.drawVignette();
    }
  }

  class Input{
    constructor(game,canvas,renderer){
      this.game=game; this.canvas=canvas; this.r=renderer;
      this.mouse={x:0,y:0};
      this.pointerDown=false;
      this.aiming=false;
      this.ballSelected=false;

      canvas.addEventListener('pointerdown', (e)=>this.onDown(e));
      window.addEventListener('pointermove', (e)=>this.onMove(e), {passive:true});
      window.addEventListener('pointerup', (e)=>this.onUp(e));
      canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
      canvas.addEventListener('touchmove', (e)=>e.preventDefault(), {passive:false});
    }

    pos(e){
      const rect=this.canvas.getBoundingClientRect();
      const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
      return { x:(e.clientX-rect.left)*dpr, y:(e.clientY-rect.top)*dpr };
    }

    hitBall(screenPos){
      const b=this.game.ball;
      const bp=this.r.w2s(b.p);
      const dx=screenPos.x-bp.x, dy=screenPos.y-bp.y;
      const dist=Math.hypot(dx,dy);
      const ballScreenR = b.r * this.r.scale;
      const extra = CONFIG.render.ballPickExtraCssPx * this.r.dpr;
      return dist <= (ballScreenR + extra);
    }

    hitPeg(screenPos, peg){
      const pp=this.r.w2s(peg.p);
      const dx=screenPos.x-pp.x, dy=screenPos.y-pp.y;
      const dist=Math.hypot(dx,dy);
      const pegScreenR = peg.r * this.r.scale;
      const extra = CONFIG.render.pegPickExtraCssPx * this.r.dpr;
      return dist <= (pegScreenR + extra);
    }

    onDown(e){
      this.pointerDown=true;
      this.mouse=this.pos(e);

      if(this.game.phase==='chooseRemoval'){
        const team=this.game.pendingRemovalTeam;
        for(const p of this.game.pegs){
          if(!p.active) continue;
          if(p.team!==team) continue;
          if(this.hitPeg(this.mouse, p)){
            this.game.choosePegToRemove(p.id);
            break;
          }
        }
        return;
      }

      if(this.game.phase!=='ready') return;
      if(!this.game.canShootNow()) return;

      if(this.hitBall(this.mouse)){
        this.ballSelected=true;
        this.aiming=true;
      }else{
        this.ballSelected=false;
        this.aiming=false;
      }
    }

    onMove(e){
      this.mouse=this.pos(e);

      if(this.game.phase==='chooseRemoval'){
        const team=this.game.pendingRemovalTeam;
        let hover=null;
        for(const p of this.game.pegs){
          if(!p.active) continue;
          if(p.team!==team) continue;
          if(this.hitPeg(this.mouse, p)){ hover=p.id; break; }
        }
        this.game.hoverPegId = hover;
      }
    }

    onUp(e){
      if(!this.pointerDown) return;
      this.pointerDown=false;

      if(this.game.phase!=='ready') { this.aiming=false; return; }
      if(!this.aiming || !this.ballSelected) { this.aiming=false; return; }
      if(!this.game.canShootNow()) { this.aiming=false; return; }

      const ball=this.game.ball;
      const bp=this.r.w2s(ball.p);

      const dx=this.mouse.x-bp.x, dy=this.mouse.y-bp.y;
      const dist=Math.hypot(dx,dy);

      const maxD=this.r.maxDragPx();
      const clamped=Math.min(dist,maxD);
      const tRaw=clamp(clamped/maxD,0,1);
      const t = Math.pow(tRaw, CONFIG.shot.responseCurve);

      if(clamped>3*this.r.dpr){
        const inv=1/(dist||1);
        const dir={ x:-dx*inv, y:-dy*inv };
        const targetSpeed = lerp(CONFIG.shot.minSpeed, CONFIG.shot.maxSpeed, t);
        ball.v.x = dir.x * targetSpeed;
        ball.v.y = dir.y * targetSpeed;
        this.game.onShot();
      }

      this.aiming=false;
    }

    resetSelection(){ this.aiming=false; this.ballSelected=false; }
  }

  class Game{
    constructor(canvas,playArea){
      this.canvas=canvas; this.playArea=playArea;

      this.scoreA=0; this.scoreB=0;
      this.turn = (Math.random()<0.5)?'A':'B';
      this.phase='ready';
      this.winner=null;

      this.ball=new Ball(CONFIG.world.w/2, CONFIG.world.h/2);
      this.pegs=[];
      this.buildFixedLayout();

      this.physics=new Physics(this);
      this.renderer=new Renderer(this, canvas, playArea);
      this.input=new Input(this, canvas, this.renderer);

      this.undoSnap=null;
      this.goalBannerUntil=0;
      this.pauseUntil=0;
      this.simStartMs=0;

      this.pendingCornerTeam=null;
      this.pendingRemovalTeam=null;
      this.pendingGoal=null;
      this.hoverPegId=null;

      this.acc=0;
      this.last=nowMs();

      this.bindUI();
      this.updateHUD();

      this.placeBallAtCornerForTeam(this.turn, Math.random()<0.5 ? 'top' : 'bottom');
      requestAnimationFrame(()=>this.loop());
    }

    bindUI(){
      document.getElementById('reset').addEventListener('click', ()=>this.reset());
      document.getElementById('undo').addEventListener('click', ()=>this.undo());

      document.getElementById('help').addEventListener('click', ()=>document.getElementById('helpBack').classList.add('show'));
      document.getElementById('closeHelp').addEventListener('click', ()=>document.getElementById('helpBack').classList.remove('show'));
      document.getElementById('helpBack').addEventListener('click', (e)=>{
        if(e.target.id==='helpBack') document.getElementById('helpBack').classList.remove('show');
      });

      document.getElementById('cornerTop').addEventListener('click', ()=>this.chooseCorner('top'));
      document.getElementById('cornerBottom').addEventListener('click', ()=>this.chooseCorner('bottom'));

      const hint = document.getElementById('hintCard');
      const toggle = () => {
        hint.classList.toggle('compact');
        const expanded = !hint.classList.contains('compact');
        hint.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        document.getElementById('hintChev').textContent = expanded ? '▾' : '▸';
      };
      hint.addEventListener('click', toggle);
      hint.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); toggle(); }});

      const autoCompact = () => {
        const small = window.innerHeight < 680;
        hint.classList.toggle('compact', small);
        const expanded = !hint.classList.contains('compact');
        hint.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        document.getElementById('hintChev').textContent = expanded ? '▾' : '▸';
      };
      window.addEventListener('resize', autoCompact);
      autoCompact();
    }

    setOverlay(id, show){
      document.getElementById(id).classList.toggle('show', !!show);
    }

    buildFixedLayout(){
      this.pegs=[];
      const W=CONFIG.world.w, H=CONFIG.world.h;

      const A = [
        [90, H*0.50],
        [220, H*0.20],[240, H*0.38],[240, H*0.62],[220, H*0.80],
        [360, H*0.22],[380, H*0.40],[380, H*0.60],[360, H*0.78],
        [520, H*0.32],[520, H*0.68],
      ];
      const B = [
        [W-90, H*0.50],
        [W-220, H*0.20],[W-240, H*0.38],[W-240, H*0.62],[W-220, H*0.80],
        [W-360, H*0.22],[W-380, H*0.40],[W-380, H*0.60],[W-360, H*0.78],
        [W-520, H*0.32],[W-520, H*0.68],
      ];

      for(let i=0;i<CONFIG.teams.count;i++) this.pegs.push(new Peg(A[i][0],A[i][1],'A',`A${i}`));
      for(let i=0;i<CONFIG.teams.count;i++) this.pegs.push(new Peg(B[i][0],B[i][1],'B',`B${i}`));

      for(const p of this.pegs){
        p.p.x += rand(-6,6);
        p.p.y += rand(-8,8);
      }
    }

    updateHUD(){
      document.getElementById('scoreA').textContent=String(this.scoreA);
      document.getElementById('scoreB').textContent=String(this.scoreB);
      document.getElementById('turnText').textContent=(this.turn==='A')?'Equipo A':'Equipo B';
      document.getElementById('turnPill').style.background=(this.turn==='A')?'#4da3ff':'#ff6b6b';
      document.getElementById('undo').disabled = !this.undoSnap || this.phase!=='ready';
    }

    canShootNow(){ return this.phase==='ready' && this.ball.speed()<0.5; }

    snapshot(){
      return {
        turn:this.turn, scoreA:this.scoreA, scoreB:this.scoreB,
        phase:this.phase, winner:this.winner,
        goalBannerUntil:this.goalBannerUntil, pauseUntil:this.pauseUntil,
        pendingCornerTeam:this.pendingCornerTeam,
        pendingRemovalTeam:this.pendingRemovalTeam,
        pendingGoal:this.pendingGoal,
        ball:{ p:{x:this.ball.p.x,y:this.ball.p.y}, v:{x:this.ball.v.x,y:this.ball.v.y} },
        pegs:this.pegs.map(p=>({
          id:p.id, team:p.team, active:p.active,
          removedPose: p.removedPose ? {x:p.removedPose.x,y:p.removedPose.y,angle:p.removedPose.angle} : null
        })),
      };
    }

    applySnapshot(s){
      this.turn=s.turn; this.scoreA=s.scoreA; this.scoreB=s.scoreB;
      this.phase=s.phase; this.winner=s.winner;
      this.goalBannerUntil=s.goalBannerUntil||0;
      this.pauseUntil=s.pauseUntil||0;
      this.pendingCornerTeam=s.pendingCornerTeam||null;
      this.pendingRemovalTeam=s.pendingRemovalTeam||null;
      this.pendingGoal=s.pendingGoal||null;

      this.ball.p.x=s.ball.p.x; this.ball.p.y=s.ball.p.y;
      this.ball.v.x=s.ball.v.x; this.ball.v.y=s.ball.v.y;

      const map=new Map(this.pegs.map(p=>[p.id,p]));
      for(const sp of s.pegs){
        const p=map.get(sp.id);
        if(!p) continue;
        p.active=sp.active;
        p.removedPose = sp.removedPose ? {x:sp.removedPose.x,y:sp.removedPose.y,angle:sp.removedPose.angle} : null;
      }

      this.hoverPegId=null;
      this.input.resetSelection();
      this.setOverlay('cornerOverlay', this.phase==='waitingCorner');
      this.setOverlay('removeOverlay', this.phase==='chooseRemoval');
      this.updateHUD();
    }

    undo(){
      if(!this.undoSnap) return;
      if(this.phase!=='ready') return;
      this.applySnapshot(this.undoSnap);
      this.undoSnap=null;
      this.updateHUD();
    }

    reset(){
      this.scoreA=0; this.scoreB=0;
      this.turn=(Math.random()<0.5)?'A':'B';
      this.phase='ready'; this.winner=null;

      this.ball.p.x=CONFIG.world.w/2; this.ball.p.y=CONFIG.world.h/2;
      this.ball.v.x=0; this.ball.v.y=0;

      this.buildFixedLayout();
      this.undoSnap=null;
      this.goalBannerUntil=0;
      this.pauseUntil=0;

      this.pendingCornerTeam=null;
      this.pendingRemovalTeam=null;
      this.pendingGoal=null;
      this.hoverPegId=null;

      this.input.resetSelection();
      this.setOverlay('cornerOverlay', false);
      this.setOverlay('removeOverlay', false);

      this.placeBallAtCornerForTeam(this.turn, Math.random()<0.5 ? 'top' : 'bottom');
      this.updateHUD();
    }

    placeBallAtCornerForTeam(team, which){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const m=CONFIG.cornerMargin;
      this.ball.p.y = (which==='top') ? m : (H-m);
      this.ball.p.x = (team==='A') ? m : (W-m);
      this.ball.v.x=0; this.ball.v.y=0;
    }

    onShot(){
      this.undoSnap=this.snapshot();
      this.phase='sim';
      this.simStartMs=nowMs();
      this.updateHUD();
    }

    allStopped(){ return this.ball.speed() <= CONFIG.physics.stopSpeed; }

    checkGoal(){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const open=CONFIG.goal.opening;
      const yTop=(H-open)/2, yBot=yTop+open;
      const b=this.ball;

      const inMouth = (b.p.y>=yTop && b.p.y<=yBot);
      if(inMouth && (b.p.x + b.r < 0)) return { scorer:'B', conceded:'A' };
      if(inMouth && (b.p.x - b.r > W)) return { scorer:'A', conceded:'B' };
      return null;
    }

    nextRemovedPose(team){
      const W=CONFIG.world.w, H=CONFIG.world.h;
      const rem = CONFIG.render.removed;
      const count = this.pegs.filter(p=>!p.active && p.team===team).length;

      const baseY = 60;
      const stepY = 2*CONFIG.peg.r*rem.scale + 10;
      const y = clamp(baseY + count*stepY, 60, H-60);

      const x = (team==='A') ? (-CONFIG.goal.boxDepth - 40) : (W + CONFIG.goal.boxDepth + 40);
      const angle = rem.lieAngleBase + rand(-rem.lieAngleJitter, rem.lieAngleJitter);
      return {x, y, angle};
    }

    choosePegToRemove(pegId){
      if(this.phase!=='chooseRemoval') return;
      const team=this.pendingRemovalTeam;
      const peg=this.pegs.find(p=>p.id===pegId);
      if(!peg || !peg.active || peg.team!==team) return;

      peg.active=false;
      peg.removedPose=this.nextRemovedPose(team);

      this.pendingCornerTeam = team;
      this.pendingRemovalTeam = null;
      this.phase='waitingCorner';
      this.setOverlay('removeOverlay', false);

      const teamName = (this.pendingCornerTeam==='A') ? 'Equipo A' : 'Equipo B';
      document.getElementById('cornerTitle').textContent = `Saque tras gol · ${teamName}`;
      document.getElementById('cornerDesc').textContent = `El ${teamName} recibió el gol. Elige una de tus dos esquinas para sacar.`;
      this.setOverlay('cornerOverlay', true);

      this.updateHUD();
    }

    applyGoal(g){
      if(g.scorer==='A') this.scoreA++; else this.scoreB++;

      this.goalBannerUntil=nowMs()+CONFIG.effects.goalBannerMs;
      document.getElementById('goalBanner').classList.add('show');

      this.ball.v.x=0; this.ball.v.y=0;
      this.ball.p.x = CONFIG.world.w/2;
      this.ball.p.y = CONFIG.world.h/2;

      if(this.scoreA>=11 || this.scoreB>=11){
        this.phase='gameover';
        this.winner=(this.scoreA>=11)?'A':'B';
        this.pendingCornerTeam=null;
        this.pendingRemovalTeam=null;
        this.setOverlay('cornerOverlay', false);
        this.setOverlay('removeOverlay', false);
        this.updateHUD();
        return;
      }

      this.turn = g.conceded;
      this.pendingRemovalTeam = g.conceded;
      this.pendingCornerTeam = null;
      this.pendingGoal = g;

      this.phase='chooseRemoval';
      this.hoverPegId=null;
      this.input.resetSelection();

      const teamName = (this.pendingRemovalTeam==='A') ? 'Equipo A' : 'Equipo B';
      document.getElementById('removeTitle').textContent = `Retirar palito · ${teamName}`;
      document.getElementById('removeDesc').textContent = `Te han metido gol. Toca uno de tus palitos (${teamName}) para retirarlo (quedará tumbado fuera del campo).`;
      this.setOverlay('removeOverlay', true);
      this.setOverlay('cornerOverlay', false);

      this.updateHUD();
    }

    chooseCorner(which){
      if(this.phase!=='waitingCorner') return;
      const team=this.pendingCornerTeam;
      if(!team) return;

      this.placeBallAtCornerForTeam(team, which);
      this.pendingCornerTeam=null;

      this.setOverlay('cornerOverlay', false);
      this.pauseUntil=nowMs()+CONFIG.effects.goalPauseMs;
      this.phase='paused';
      this.updateHUD();
    }

    drawGameOverOverlay(){
      const ctx=this.renderer.ctx;
      const w=this.renderer.w, h=this.renderer.h;
      const dpr=this.renderer.dpr;

      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.35)';
      ctx.fillRect(0,0,w,h);

      const text=(this.winner==='A')?'¡GANA EQUIPO A!':'¡GANA EQUIPO B!';
      ctx.font=`1000 ${Math.floor(54*dpr)}px system-ui`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='rgba(255,255,255,.92)';
      ctx.shadowColor='rgba(0,0,0,.45)';
      ctx.shadowBlur=18*dpr;
      ctx.fillText(text,w/2,h/2-22*dpr);
      ctx.shadowBlur=0;

      ctx.font=`800 ${Math.floor(16*dpr)}px system-ui`;
      ctx.fillStyle='rgba(234,240,255,.85)';
      ctx.fillText('Pulsa “Reiniciar partido” para jugar otra vez.',w/2,h/2+28*dpr);
      ctx.restore();
    }

    loop(){
      const t=nowMs();
      const dtFrame=Math.min((t-this.last)/1000, 0.05);
      this.last=t;
      this.acc += dtFrame;

      if(t>=this.goalBannerUntil){
        document.getElementById('goalBanner').classList.remove('show');
      }

      if(this.phase==='paused' && t>=this.pauseUntil){
        this.phase='ready';
        this.updateHUD();
      }

      if(this.phase==='sim'){
        const fixed=CONFIG.physics.dt;
        let steps=0;
        while(this.acc>=fixed && steps<CONFIG.physics.maxSubStepsPerFrame){
          this.physics.step(fixed);
          this.acc -= fixed;
          steps++;
        }

        const goal=this.checkGoal();
        if(goal){
          this.applyGoal(goal);
        }else{
          const elapsed=(t-this.simStartMs)/1000;
          if(this.allStopped() || elapsed>=CONFIG.physics.maxSimSeconds){
            this.ball.v.x=0; this.ball.v.y=0;
            this.phase='ready';
            this.turn=(this.turn==='A')?'B':'A';
            this.input.resetSelection();
            this.updateHUD();
          }
        }
      }

      this.renderer.draw();
      if(this.phase==='gameover') this.drawGameOverOverlay();

      requestAnimationFrame(()=>this.loop());
    }
  }

  const canvas=document.getElementById('c');
  const playArea=document.getElementById('playArea');
  new Game(canvas,playArea);

  document.getElementById('help').addEventListener('click', ()=>document.getElementById('helpBack').classList.add('show'));
  document.getElementById('closeHelp').addEventListener('click', ()=>document.getElementById('helpBack').classList.remove('show'));
  document.getElementById('helpBack').addEventListener('click', (e)=>{
    if(e.target.id==='helpBack') document.getElementById('helpBack').classList.remove('show');
  });
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Escape') document.getElementById('helpBack').classList.remove('show');
  });
})();
</script>

<!--
Cómo jugar:
- Tras gol aparece un panel informativo, pero el campo sigue siendo clicable.
- Toca un palito del equipo que encajó para retirarlo.

Parámetros:
- Si quieres que el panel moleste aún menos: en .overlay usa padding más pequeño o reduce width de .panel.
-->
</body>
</html>
